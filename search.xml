<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Activity的几种启动模式</title>
    <url>/blog/2017-03-18-Activity%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="Activity的启动模式"><a href="#Activity的启动模式" class="headerlink" title="Activity的启动模式"></a>Activity的启动模式</h2><p>Android 提供了四种Activity启动方式：</p>
<h3 id="1-标准模式：standard"><a href="#1-标准模式：standard" class="headerlink" title="1.标准模式：standard"></a>1.标准模式：standard</h3><p>每启动一次Activity，就会创建一个新的Activity实例并置于栈顶。谁启动了这个Activity，那么这个Activity就运行在启动它的那个Activity所在的栈中。<span id="more"></span></p>
<p>特殊情况下，如果在Service或Application中启动一个Activity，其并没有所谓的任务栈，可以使用标记位Flag来解决。解决办法：为待启动的Activity指定FLAG_ACTIVITY_NEW_TASK标记位，创建一个新栈。</p>
<h3 id="2-栈顶复用模式：singleTop"><a href="#2-栈顶复用模式：singleTop" class="headerlink" title="2.栈顶复用模式：singleTop"></a>2.栈顶复用模式：singleTop</h3><p>如果需要新建的Activity位于任务栈栈顶，那么此Activity的实例就不会重建，而是复用栈顶的实例。并回调：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onNewIntent</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">     <span class="built_in">super</span>.onNewIntent(intent);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>由于不会重建一个Activity实例，则不会回调其他生命周期方法。</p>
<p>应用场景：在通知栏点击收到的通知，然后需要启动一个Activity，这个Activity就可以用singleTop，否则每次点击都会新建一个Activity。</p>
<h3 id="3-栈内复用模式：singleTask"><a href="#3-栈内复用模式：singleTask" class="headerlink" title="3.栈内复用模式：singleTask"></a>3.栈内复用模式：singleTask</h3><p>该模式是一种单例模式，即一个栈内只有一个该Activity实例。singleTask会具有clearTop特性，会把之上的栈内Activity清除。与singleTop一样，系统也会回调它的onNewIntent方法。</p>
<p>当一个singleTask模式的Activity请求启动后，系统会首先寻找是否存在这个Activity想要的任务栈，如果不存在，就创建一个新的任务栈，然后创建Activity的实例后把这个Activity放入到这个任务栈中。如果存在所需要的任务栈，这时，要看这个Activity是否在栈中有实例存在，如果有，那么系统就会把这个Activity调用到栈顶，并调用它的onNewIntent方法。如果不存在，就会创建这个Activity的实例，并将其压入栈顶。</p>
<p>该模式，可以通过在AndroidManifest文件的Activity中指定该Activity需要加载到哪个栈中，即singleTask的Activity可以指定想要加载的目标栈。singleTask和taskAffinity配合使用，指定开启的Activity加入到哪个栈中。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.Activity1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:launchMode</span>=<span class="string">&quot;singleTask&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:taskAffinity</span>=<span class="string">&quot;com.test.task&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>关于taskAffinity</strong>：TaskAffinity可以理解为任务相关性，这个参数标识了Activity所需要的任务栈名字。每个Activity都有taskAffinify属性，这个属性指出了它希望进入的任务栈。如果一个Activity没有显式的指明该Activity的taskAffinity，那么它的这个属性就等于Application指明的taskAffinity，如果Application也没有指明，那么该taskAffinity的值就等于包名。</p>
<p>上述配置中，Activity1指定了taskAffinity为“com.test.task”，在这种情况下启动Activity1，如果“com.test.task”栈不存在，则创建这个栈，并把创建的Activity压入这个栈内。如果“com.test.task”栈存在，并且其中没有该Activity实例，则会创建Activity并压入栈顶，如果这个任务栈中有该Activity实例，则clearTop把该Activity实例之上的Activity杀死并出栈，重用并让该Activity实例处在栈顶，然后调用onNewIntent()方法。</p>
<p><strong>singleTask应用场景：</strong></p>
<p>对于大部分应用，当我们在主界面点击返回按钮都是退出应用，那么当我们第一次进入主界面之后，主界面位于栈底，以后不管我们打开了多少个Activity，只要我们再次回到主界面，都应该使用将主界面Activity上所有的Activity移除的方式来让主界面Activity处于栈顶，而不是往栈顶新加一个主界面Activity的实例，通过这种方式能够保证退出应用时所有的Activity都能被销毁。</p>
<h3 id="4-单例模式：singleInstance"><a href="#4-单例模式：singleInstance" class="headerlink" title="4.单例模式：singleInstance"></a>4.单例模式：singleInstance</h3><p>作为栈内复用的加强版，打开该Activity时，直接创建一个新的任务栈，并创建该Activity实例放入栈中。一旦该模式的Activity实例已经存在于某个栈中，任何应用在激活该Activity时都会重用该栈中的实例。</p>
<p>应用场景：呼叫来电界面</p>
<h2 id="场景分析"><a href="#场景分析" class="headerlink" title="场景分析"></a>场景分析</h2><p>假设当前有两个任务栈，前台任务栈中有AB（自栈底到栈顶，下同）两个Activity，后台任务栈有CD两个Activity。如果CD都被设置了SingleTask，此时，通过A启动D，那么整个后台任务栈都会被切换到前台，可以理解为栈变成了ABCD的顺序，此时按back按键后，D出栈，C显示；再次按back键，C出栈，B显示，以此类推。</p>
<p>如果上述场景中A启动的是C而不是D，那么D会被首先clearTop掉，即任务栈变为ABC，按返回时C先出栈，接着B、A出栈。</p>
<h2 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h2><h3 id="1-一个被设置为standard模式的Activity在被ApplicationContext启动时会什么会报错？"><a href="#1-一个被设置为standard模式的Activity在被ApplicationContext启动时会什么会报错？" class="headerlink" title="1.一个被设置为standard模式的Activity在被ApplicationContext启动时会什么会报错？"></a>1.一个被设置为standard模式的Activity在被ApplicationContext启动时会什么会报错？</h3><p>因为standard模式的Activity默认会进入启动它的Activity所属的任务栈，但是由于非Activity类型的Context自身并没有所属的任务栈，因此，此时启动standard模式的Activity就有问题了。可以通过给待启动的Activity指定FLAG_ACTIVITY_NEW_TASK标记位，这样在启动这个Activity时就会为它创建一个新的任务栈。此时，这个Activity实际上是以singleTask模式启动的。</p>
<h3 id="2-有A、B、C三个Activity，其中A启动模式为standard，taskAffinity为默认。B和C的启动模式都设置为singleTask-并且都指定taskAffinity为”com-test-task”。此时，如果在A中点击按钮启动B，在B中点击按钮又启动C，在C中点击按钮又启动A，最后在A中点击按钮启动B。现在按两次返回键会回到哪里？"><a href="#2-有A、B、C三个Activity，其中A启动模式为standard，taskAffinity为默认。B和C的启动模式都设置为singleTask-并且都指定taskAffinity为”com-test-task”。此时，如果在A中点击按钮启动B，在B中点击按钮又启动C，在C中点击按钮又启动A，最后在A中点击按钮启动B。现在按两次返回键会回到哪里？" class="headerlink" title="2.有A、B、C三个Activity，其中A启动模式为standard，taskAffinity为默认。B和C的启动模式都设置为singleTask,并且都指定taskAffinity为”com.test.task”。此时，如果在A中点击按钮启动B，在B中点击按钮又启动C，在C中点击按钮又启动A，最后在A中点击按钮启动B。现在按两次返回键会回到哪里？"></a>2.有A、B、C三个Activity，其中A启动模式为standard，taskAffinity为默认。B和C的启动模式都设置为singleTask,并且都指定taskAffinity为”com.test.task”。此时，如果在A中点击按钮启动B，在B中点击按钮又启动C，在C中点击按钮又启动A，最后在A中点击按钮启动B。现在按两次返回键会回到哪里？</h3><p>会回到桌面。第一次A启动B，由于B指定了单独的任务栈“com.test.task”,因此会首先创建”com.test.task”任务栈（以下简称该任务栈为T），然后实例化B，并将B加入T任务栈中。此时B启动C，由于C与B指定的都是T任务中，因此C会实例化后加入到T任务栈，接着在C中启动A，由于此时T任务栈中没有A，因此会实例化A并将A加入到T任务栈。接着A再次启动B，由于B已经存在于T任务栈中，因此会执行clearTop，将C和A都出栈，然后显示出B。此时点击返回B会finish掉，此时后台任务栈中的A会显示出来，再次点击返回，A结束回到桌面。</p>
<link rel="stylesheet" href="/css/markmap.css" type="text/css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android View 绘制流程</title>
    <url>/blog/2018-10-28-Android%20View%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为一名Android开发者肯定明白View的地位，说它占据半壁江山也不为过，作为基石之一，搞明白它的加载流程是每个开发者都应该去做的，目前网络上很多关于View绘制流程的文章，有些质量也很高，但我还是想以自己的思路出一篇文章。相信读完你对View的工作机制以及自定义View会有一个全新的认识。</p>
<h2 id="1-View的绘制时机"><a href="#1-View的绘制时机" class="headerlink" title="1. View的绘制时机"></a>1. View的绘制时机</h2><h3 id="1-1-知识储备"><a href="#1-1-知识储备" class="headerlink" title="1.1. 知识储备"></a>1.1. 知识储备</h3><ul>
<li>Window：每个Activity都会创建一个Window用于承载View视图的显示，Window是一个抽象类存在了一个唯一实现类PhoneWindow <span id="more"></span></li>
<li>DecorView：最顶层的View，是一个FrameLayout子类，最终会被加载到Window当中，它内部只有一个垂直方向的LinearLayout分为两部分：<ul>
<li>TitleBar：屏幕顶部的状态栏</li>
<li>ContentView：Activity对应的XML布局，通过setContentView设置到DecorView中。</li>
</ul>
</li>
</ul>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-4918971/hf6e6jt80h.png?imageView2/2/w/1620"></p>
<h3 id="1-2-Activity、Window、DecorView之间关系"><a href="#1-2-Activity、Window、DecorView之间关系" class="headerlink" title="1.2. Activity、Window、DecorView之间关系"></a>1.2. Activity、Window、DecorView之间关系</h3><p>首先来看一下Activity中setContentView源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContentView</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="type">int</span> layoutResID)</span> &#123;</span><br><span class="line">       <span class="comment">//将xml布局传递到Window当中</span></span><br><span class="line">       getWindow().setContentView(layoutResID);</span><br><span class="line">       initWindowDecorActionBar();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>从代码可以看出，Activity的setContentView实质是将View传递到Window的setContentView()方法中，Window的setContenView会在内部调用installDecor()方法创建DecorView，看一下它的部分源码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContentView</span><span class="params">(<span class="type">int</span> layoutResID)</span> &#123; </span><br><span class="line">       <span class="keyword">if</span> (mContentParent == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">//初始化DecorView以及其内部的content</span></span><br><span class="line">           installDecor();</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">           mContentParent.removeAllViews();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">       ...............</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//将contentView加载到DecorVoew当中</span></span><br><span class="line">           mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line">       &#125;</span><br><span class="line">       ...............</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">installDecor</span><span class="params">()</span> &#123;</span><br><span class="line">       ...............</span><br><span class="line">       <span class="keyword">if</span> (mDecor == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">//实例化DecorView</span></span><br><span class="line">           mDecor = generateDecor(-<span class="number">1</span>);</span><br><span class="line">           ...............</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           mDecor.setWindow(<span class="built_in">this</span>);</span><br><span class="line">       &#125;</span><br><span class="line">      <span class="keyword">if</span> (mContentParent == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">//获取Content</span></span><br><span class="line">           mContentParent = generateLayout(mDecor);</span><br><span class="line">      &#125;  </span><br><span class="line">       ...............</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> DecorView <span class="title function_">generateDecor</span><span class="params">(<span class="type">int</span> featureId)</span> &#123;</span><br><span class="line">       ...............</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DecorView</span>(context, featureId, <span class="built_in">this</span>, getAttributes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过generateDecor()new一个DecorView，然后调用generateLayout()获取DecorView中content，最终通过inflate将Activity视图添加到DecorView中的content中，但此时DecorView还未被添加到Window中。添加操作需要借助ViewRootImpl。</p>
<p>ViewRootImpl的作用是用来衔接WindowManager和DecorView，在Activity被创建后会通过WindowManager将DecorView添加到PhoneWindow中并且创建ViewRootImpl实例，随后将DecorView与ViewRootImpl进行关联，最终通过执行ViewRootImpl的performTraversals()开启整个View树的绘制。</p>
<p>关于Activity在何时将DecorView添加到Window以及何时创建 ViewRootImpl，这块内容牵扯面比较广，涉及到Activity启动流程、ActivityManagerService(AMS)、WindowManagerService(WMS)，内容太过于深入加上作者能力有限就不误人子弟了。如有兴趣推荐查阅刘皇叔《Android进阶解密》，书中对这方面内容讲解还是比较全面的 。</p>
<h2 id="2-绘制过程"><a href="#2-绘制过程" class="headerlink" title="2. 绘制过程"></a>2. 绘制过程</h2><p>从第一小节可知，View的绘制是从ViewRootImpl的performTraversals()方法开始，从最顶层的View(ViewGroup)开始逐层对每个View进行绘制操作，下面来看一下该方法部分源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">performTraversals</span><span class="params">()</span> &#123;</span><br><span class="line">     ...............</span><br><span class="line">    <span class="comment">//measur过程</span></span><br><span class="line">    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">     ...............</span><br><span class="line">    <span class="comment">//layout过程</span></span><br><span class="line">    performLayout(lp, desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">     ...............</span><br><span class="line">    <span class="comment">//draw过程</span></span><br><span class="line">    performDraw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这方法大概有几百行，机智的作者抽出三句精华呈现给大家~~~</p>
<p>measure：为测量宽高过程，如果是ViewGroup还要在onMeasure中对所有子View进行measure操作。<br>layout：用于摆放View在ViewGroup中的位置，如果是ViewGroup要在onLayout方法中对所有子View进行layout操作。<br>draw：往View上绘制图像。  </p>
<p>示意图如下： 确实不想画图了，从刚哥的书里拍一张吧～～～  </p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-4918971/w7rt5euzw7.png?imageView2/2/w/1620"></p>
<h3 id="2-1-Measure"><a href="#2-1-Measure" class="headerlink" title="2.1 Measure"></a>2.1 Measure</h3><p>performMeasure()源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">performMeasure</span><span class="params">(<span class="type">int</span> childWidthMeasureSpec, <span class="type">int</span> childHeightMeasureSpec)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (mView == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出从mView(最顶层ViewGroup)开始进行测量操作，然后逐层遍历View并执行measure操作。</p>
<p>MeasureSpac<br>Measure是View绘制三个过程中的第一步，提到Measure就不得不提MeasureSpac它是一个32位int类型数值，高两位SpacMode代表测量模式，低30位SpacSize代表测量尺寸，是View的内部类，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MeasureSpec</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MODE_SHIFT</span> <span class="operator">=</span> <span class="number">30</span>;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MODE_MASK</span>  <span class="operator">=</span> <span class="number">0x3</span> &lt;&lt; MODE_SHIFT;  </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNSPECIFIED</span> <span class="operator">=</span> <span class="number">0</span> &lt;&lt; MODE_SHIFT;  </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EXACTLY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; MODE_SHIFT;  </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">AT_MOST</span> <span class="operator">=</span> <span class="number">2</span> &lt;&lt; MODE_SHIFT;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>内部也包含三种测量模式：</p>
<p>UNSPECIFIED ：父布局不会对子View做任何限制，例如我们常用的ScrollView就是这种测量模式。<br>EXACTLY ：精确数值，比如使用了match_parent或者xxxdp，表示父布局已经决定了子View的大小，通常在这种情况下View的尺寸就是SpacSize<br>AT_MOST ：自适应，对应wrap_content子View可以根据内容设置自己的大小，但前提是不能超出父ViewGroup的宽高。  </p>
<p>注意点：<br>在我们自定义View的过程中都会在onMeasure中进行宽高的测量，这个方法会从父布局中接收两个参数widthMeasureSpac和heightMeasureSpac，所以子布局的宽高大小需要受限于父布局。</p>
<p>在自定义View宽高测量的过程中，我们需要获取MeasurSpac中的宽高和测量模式，自定义ViewGroup也必须给子View传递MeasurSpac，Android也给我们提供了计算MeasurSpac 和通过MeasurSpac 获取相应值的方式，都位于MeasurSpac中，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MeasureSpec</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">makeMeasureSpec</span><span class="params">( <span class="type">int</span> size, <span class="type">int</span> mode)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (sUseBrokenMakeMeasureSpec) &#123;</span><br><span class="line">                <span class="keyword">return</span> size + mode;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);</span><br><span class="line">            &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMode</span><span class="params">(<span class="type">int</span> measureSpec)</span> &#123;</span><br><span class="line">            <span class="comment">//noinspection ResourceType</span></span><br><span class="line">            <span class="keyword">return</span> (measureSpec &amp; MODE_MASK);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">(<span class="type">int</span> measureSpec)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (measureSpec &amp; ~MODE_MASK)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从ViewGroup到View对尺寸和模式进行了一次封装和拆解，其目的是为了减少对象的创建，避免造成不必要的内存浪费。</p>
<p>LayoutParams<br>在刚接触Android的时候经常有一个疑问，为什么View设置自己的宽高，还要创建一个xxx.LayoutParams？前面也提到了，子View的宽高是要受限于父布局的，所以不能通过setWidth或者setHeight直接设置宽高的，另外 LayoutParams的作用不仅如此，比如一个View的父布局是RelativeLayout，可以通过设置RelativeLayout.LayoutParams的above，below等属性来调整在父布局中的位置。</p>
<p>自定义View宽高测量演示<br>创建一个类继承View，重写其onMeasure()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onMeasure</span><span class="params">(<span class="type">int</span> widthMeasureSpec, <span class="type">int</span> heightMeasureSpec)</span> &#123;</span><br><span class="line">       <span class="comment">//默认宽  </span></span><br><span class="line">       <span class="type">int</span> <span class="variable">defaultWidth</span> <span class="operator">=</span> <span class="number">0</span>;    </span><br><span class="line">       <span class="comment">//默认高</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">defaultHeight</span> <span class="operator">=</span> <span class="number">0</span>;    </span><br><span class="line">       setMeasuredDimension(</span><br><span class="line">            getDefaultSize(defaultWidth, widthMeasureSpec),  </span><br><span class="line">            getDefaultSize(defaultHeight, heightMeasureSpec));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般的自定义View中，如果对宽高没有特殊需求可直接通过getDefaultSize()方法获取，该方法位于View中源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getDefaultSize</span><span class="params">(<span class="type">int</span> size, <span class="type">int</span> measureSpec)</span> &#123;</span><br><span class="line">     <span class="comment">//默认尺寸</span></span><br><span class="line">     <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> size;</span><br><span class="line">     <span class="comment">//获取测量模式</span></span><br><span class="line">     <span class="type">int</span> <span class="variable">specMode</span> <span class="operator">=</span> MeasureSpec.getMode(measureSpec);</span><br><span class="line">     <span class="comment">//获取尺寸</span></span><br><span class="line">     <span class="type">int</span> <span class="variable">specSize</span> <span class="operator">=</span> MeasureSpec.getSize(measureSpec);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">            result = size;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">            result = specSize;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>从代码分析可知，获取mode和size后会分别对三种测量模式进行判断，UNSPECIFIED使用默认尺寸，而AT_MOST和EXACTLY使用父布局给出的测量尺寸。尺寸计算完毕后通过setMeasuredDimension(width,height)设置最终宽高。</p>
<h3 id="2-2-Layout"><a href="#2-2-Layout" class="headerlink" title="2.2 Layout"></a>2.2 Layout</h3><p>performLayout()部分源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">performLayout</span><span class="params">(WindowManager.LayoutParams lp, <span class="type">int</span> desiredWindowWidth,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> desiredWindowHeight)</span> &#123;</span><br><span class="line">        .........</span><br><span class="line">        <span class="keyword">final</span> <span class="type">View</span> <span class="variable">host</span> <span class="operator">=</span> mView;</span><br><span class="line">        <span class="keyword">if</span> (host == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        host.layout(<span class="number">0</span>, <span class="number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line">        .........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟measure类似，同样是从mView(最顶层ViewGroup)开始进行layout操作，随后逐层遍历。layout(l,t,r,b)四个参数分别对应左上右下的位置，从而确定View在ViewGroup中的位置。下面来看一下layout()部分源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">layout</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> t, <span class="type">int</span> r, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    .......</span><br><span class="line">    <span class="comment">//通过setOpticalFrame()和setFrame()老确定四个点的位置</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">changed</span> <span class="operator">=</span> isLayoutModeOptical(mParent) ? </span><br><span class="line">    setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class="line">    .......</span><br><span class="line">    <span class="comment">//调用onLayout()，ViewGroup须重写此方法</span></span><br><span class="line">    onLayout(changed, l, t, r, b);</span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合源码可知layout()会将四个位置参数传递给setOpticalFrame()或者setFrame()，而setOpticalFrame()内部会调用setFrame()，所以最终通过setFrame()确定View在ViewGroup中的位置。位置确定完毕会调用onLayout(l,t,r,b)对子View进行摆放。</p>
<p>onLayout()<br>View和ViewGroup在执行完setFrame()后都会调用onLayout()方法，但上面也有提到该方法的作用是对子View进行位置摆放，所以单一View是不需要重写此方法。而ViewGroup会根据自己的特性任意对子View进行摆放。</p>
<h3 id="2-3-Draw"><a href="#2-3-Draw" class="headerlink" title="2.3 Draw"></a>2.3 Draw</h3><p>相信很多学习自定义View的同学都是奔着有朝一日自己也实现那些眼花缭乱的效果，起码我自己就是。我们在手机上看到的那些五彩缤纷的图片，动画都是在这个方法内绘制而成。</p>
<p>相比于measure和layout阶段，draw阶段中View和ViewGroup变得没那么紧密了，View的绘制过程中不需要考虑ViewGroup，而ViewGroup也只需触发子View的绘制方法即可。</p>
<p>performDraw()执行后同样会从根布局开始逐层对每个View进行draw操作，在View中绘制操作时通过draw()进行，来看一下其主要源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(Canvas canvas)</span> &#123;</span><br><span class="line">     ........</span><br><span class="line">    <span class="comment">// 绘制背景</span></span><br><span class="line">    drawBackground(canvas);</span><br><span class="line">    <span class="comment">// 绘制内容</span></span><br><span class="line">    onDraw(canvas);</span><br><span class="line">    <span class="comment">// 绘制子View</span></span><br><span class="line">    dispatchDraw(canvas);</span><br><span class="line">    <span class="comment">// 绘制装饰,如scrollBar</span></span><br><span class="line">    onDrawForeground(canvas)</span><br><span class="line">    ........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>draw()方法中主要包含四部分内容，其中我们开发者只需要关心onDraw(canvas)即可，即自身的内容绘制。</p>
<p>绘制内容简述<br>关于绘制内容这部分可利用到的知识点很多，多到可以写一本书出来，所以仅靠本文全部详细描述显然是不现实的。下面我罗列一部分常用内容供大家参考：</p>
<p>Canvas：画布，不管是文字，图形，图片都要通过画布绘制而成<br>Paint：画笔，可设置颜色，粗细，大小，阴影等等等等，一般配合画布使用<br>Path：路径，用于形成一些不规则图形。<br>Matrix：矩阵，可实现对画布的几何变换。  </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>文章从四个方面总结了View的绘制流程：绘制时机,宽高测量,位置摆放,图像绘制，因为侧重于流程所以只是把这四部分的精华给拎出来分享给大家，起到一个抛砖引玉的作用，想要透彻理解启动流程、玩转自定义View还需要对各部分知识系统的学习。</p>
<link rel="stylesheet" href="/css/markmap.css" type="text/css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 触摸事件分发机制：事件如何到达Activity</title>
    <url>/blog/2018-06-18-Android%20%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B61/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很高兴遇见你~  </p>
<p>事件分发，android中一个老生常谈的话题了。本文要探究的是，一个触摸信息从系统底层产生之后，一步步到达Activity进行分发的整体流程。而关于系统底层的逻辑，不在本文的讨论范围内。主要的内容是分析触摸事件传递的路径。不会纠结于源码与底层，而是把触摸事件来源的大体流程呈现出来，便于对事件分发体系有个更加完整的理解。<span id="more"></span></p>
<h2 id="管理单位：window"><a href="#管理单位：window" class="headerlink" title="管理单位：window"></a>管理单位：window</h2><p>android的view管理是以window为单位的，每个window对应一个view树。这里管理涉及到view的绘制以及事件分发等。Window机制不仅管理着view的显示，也负责view的事件分发。关于window的本质，以后再写window机制。研究事件分发的来源，则必须对于window机制有一定的了解。</p>
<p>所以，首先要了解一个概念：view树。<br>我们的应用布局，一般是有多层viewGroup和view的嵌套，如下图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5301713e67a34cab8887cf5f00bd45e0~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp"></p>
<p>而他们对应的结构关系如下图所示</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/754f43ce75e841229cfc44392fdaa3a5~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp"></p>
<p>此时，我们就可以称该布局是以一个LinearLayout为根的一棵view树。LinearLayout可以直接访问FrameLayout和RelativeLayout，因为他们都是LinearLayout的子view，同样的RelativeLayout可以直接访问Button。</p>
<p>每一棵view树都有一个根，叫做ViewRootImpl ，他负责管理这整一棵view树的绘制、事件分发等。</p>
<p>我们的应用界面一般会有多个view树，我们的activity布局就是一个view树、其他应用的悬浮窗也是一个view树、dialog界面也是一个view树、我们使用windowManager添加的view也是一个view树等等。最简单的view树可以只有一个view。</p>
<p>android中view的绘制和事件分发，都是以view树为单位。每一棵view树，则为一个window 。系统服务WindowManagerService，管理界面的显示就是以window为单位，也可以说是以view树为单位。而view树是由viewRootImpl来负责管理的，所以可以说，wms（WindowManagerService的简写）管理的是viewRootImpl。如下图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af6d0eeb6fe5488690a8a6bed48d95bd~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp"></p>
<p>wms是运行在系统服务进程的，负责管理所有应用的window。应用程序与wms的通信必须通过Binder进行跨进程通信。<br>每个viewRootImpl在wms中都有一个windowState对应，wms可以通过windowState找到对应的viewRootImpl进行管理。</p>
<p>了解window机制的一个重要原因是：事件分发并不是由Activity驱动的，而是由系统服务驱动viewRootImpl来进行分发 ，甚至可以说，在框架层角度，和Activity没有任何关系。这将有助于我们对事件分发的本质理解。</p>
<p>那么触摸信息是如何一步步到达viewRootImpl？为什么说viewRootImpl是事件分发的起点？viewRootImpl如何对触摸信息进行分发处理的？这是我们接下来要讨论的。</p>
<h2 id="触摸信息是如何到达viewRootImpl的？"><a href="#触摸信息是如何到达viewRootImpl的？" class="headerlink" title="触摸信息是如何到达viewRootImpl的？"></a>触摸信息是如何到达viewRootImpl的？</h2><p>我们都知道的是，在我们手指触摸屏幕时，即产生了触摸信息。这个触摸信息由屏幕这个硬件产生，被系统底层驱动获取，交给Android的输入系统服务：InputManagerService，也就是IMS。<br>IMS会对这个触摸信息进行处理，通过WMS找到要分发的window，随后发送给对应的viewRootImpl。所以发送触摸信息的并不是WMS，WMS提供的是window的相关信息。  </p>
<p>这一部分涉及到系统底层的逻辑，不是本文的重点，感兴趣的读者推荐阅读gityuan博主的文章Input系统-事件处理全过程。这里不展开讲解。大体的过程如下图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1497277cd15b4230af087535f01078ef~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp"></p>
<p>当viewRootImpl接收到触摸信息时，也正是应用程序进程事件分发的开始。</p>
<h2 id="viewRootImpl是如何分发事件的？"><a href="#viewRootImpl是如何分发事件的？" class="headerlink" title="viewRootImpl是如何分发事件的？"></a>viewRootImpl是如何分发事件的？</h2><p>前面我们讲到，viewRootImpl管理一棵view树，view树的最外层是viewGroup,    而viewGroup继承于view。因此整一棵view树，从外部可以看做一个view。viewRootImpl接收到触摸信息之后，经过处理之后，封装成MotionEvent对象发送给他所管理的view，由view自己进行分发。  </p>
<p>前面我们讲到，view树的根节点可以是一个viewGroup，也可以是一个单独的view，因此，这里的派发就会有两种不同的方式：直接给view进行处理 or viewGroup进行事件分发。viewGroup继承自view，view中有一个方法用于分发事件：dispatchTouchEvent 。子类可重写该方法来实现自己的分发逻辑，ViewGroup重写了该方法。</p>
<p>我们的应用布局界面或者dialog的布局界面，顶层的viewGroup为DecorView，因此会调用DecorView的 dispatchTouchEvent 方法进行分发。DecorView重写了该方法，逻辑比较简单，仅仅做了一个判断：</p>
<p>DecorView.java api29</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Window.<span class="type">Callback</span> <span class="variable">cb</span> <span class="operator">=</span> mWindow.getCallback();</span><br><span class="line">    <span class="keyword">return</span> cb != <span class="literal">null</span> &amp;&amp; !mWindow.isDestroyed() &amp;&amp; mFeatureId &lt; <span class="number">0</span></span><br><span class="line">            ? cb.dispatchTouchEvent(ev) : <span class="built_in">super</span>.dispatchTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果window callBack对象不为空，则调用callBack对象的分发方法进行分发<br>如果window callBack对象为空，则调用父类ViewGroup的事件分发方法进行分发  </p>
<p>这里的windowCallBack是一个接口，他里面包含了一些window变化的回调方法，其中就有 dispatchTouchEvent ，也就是事件分发方法。</p>
<p>Activity实现了Window.CallBack接口，并在创建布局的时候，把自己设置给了DecorView，因此在Activity的布局界面中，DecorView会把事件分发给Activity进行处理。同理，在Dialog的布局界面中，会分发给实现了callBack接口的Dialog。</p>
<p>而如果顶层的viewGroup不是DecorView，那么对调用对应view的dispatchTouchEvent方法进行分发。例如，顶层的view是一个Button，那么会直接调用Button的 dispatchTouchEvent 方法；如果顶层viewGroup子类没有重写 dispatchTouchEvent 方法，那么会直接调用ViewGroup默认的 dispatchTouchEvent 方法。</p>
<p>整体的流程如下图：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce4115c10663451ab8add7741175279c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp"></p>
<ol>
<li>viewRootImpl会直接调用管理的view的 dispatchTouchEvent 方法，根据具体的view的类型，调用具体的方法。  </li>
<li>view树的根view可能是一个view，也可能是一个viewGroup，view会直接处理事件，而viewGroup则会进行分发。  </li>
<li>DecorView重写了 dispatchTouchEvent 方法，会先判断是否存在callBack，优先调用callBack的方法，也就是把事件传递给了Activity。  </li>
<li>其他的viewGroup子类会根据自身的逻辑进行事件分发。  </li>
</ol>
<p>因此，触摸事件一定是从Activity开始的吗？不是,Activity只是其中的一种情况，只有Activity自己负责的那一棵view树，才一定会到达activity，而其他的window，则不会经过Activity。触摸事件是从viewRootImpl开始，而不是Activity。</p>
<h2 id="控件对于事件的分发"><a href="#控件对于事件的分发" class="headerlink" title="控件对于事件的分发"></a>控件对于事件的分发</h2><p>到这里，我们知道触摸事件是先发送到viewRootImpl，然后由viewRootImpl调用其所管理的view的方法进行事件分发。按照正常的流程，view会按照控件树向下去分发。而事件却到了activity、dialog，就是因为DecorView这个“叛徒”的存在。</p>
<p>前面讲到，DecorView和其他的viewGroup很不一样，他有一个windowCallBack，会优先把触摸事件发送给callBack，从而导致触摸事件脱离了控件树。那么，这些callBack是如何处理触摸事件的？触摸事件又是如何再一次回到控件树进行分发的呢？</p>
<p>了解具体的分发之前，需要先来了解一个类：PhoneWindow。<br>PhoneWindow继承自抽象类Window，但是，他本身并不是一个window，而是一个窗口功能辅助类。我们知道，一个view树，或者说控件树，就是一个window。PhoneWindow内部维护着一个控件树和一些window参数，这个控件树的根view，就是DecorView。他们和Activity的关系如下图：  </p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2378be4a614048c1b577d5961088a68b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp"></p>
<p>我们的Activity通过直接持有PhoneWindow实例从而来管理这个控件树。DecorView可以认为是一个界面模板，他的布局大概如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2684b1008543460ca5bf24b9684f8148~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp"></p>
<p>我们的Activity布局，就被添加到内容栏中，属于DecorView控件树的一部分。这样Activity可以通过PhoneWindow，间接管理自身的界面，把window相关的操作都托管给PhoneWindow，减轻自身负担。</p>
<p>PhoneWindow并不是Activity专属的，其他如Dialog也是自己创建了一个PhoneWindow。PhoneWindow仅仅只是作为一个窗口功能辅助类，帮助控件更好地创建与管理界面。</p>
<p>前面讲到，DecorView接收到事件之后，会调用windowCallBack的方法进行事件分发，我们先来看看Activity是如何分发的：</p>
<h3 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h3><p>我们首先看到Activity对于callBack接口方法的实现：<br>Activity.java api29  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">    <span class="comment">// down事件，回调onUserInteraction方法</span></span><br><span class="line">    <span class="comment">// 这个方法是个空实现，给开发者去重写</span></span><br><span class="line">    <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        onUserInteraction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// getWindow返回的就是PhoneWindow实例</span></span><br><span class="line">    <span class="comment">// 直接调用PhoneWindow的方法</span></span><br><span class="line">    <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果前面分发过程中事件没有被处理，那么调用Activity自身的方法对事件进行处理</span></span><br><span class="line">    <span class="keyword">return</span> onTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到Activity对于事件的分发逻辑还是比较简单的，直接调用PhoneWindow的方法进行分发。如果事件没有被处理，那么自己处理这个事件。接下来看看PhoneWindow如何处理：</p>
<p>PhoneWindow.java api29  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mDecor.superDispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的mDecor就是PhoneWindow内部维护的DecorView了，简单粗暴，直接调用DecorView的方法进行分发。看到DecorView的方法：</p>
<p>DecorView.java api29  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好家伙，DecorView对于事件也是没有做任何处理，直接调用父类的方法进行分发。DecorView继承自FrameLayout，但是FrameLayout并没有重写 dispatchTouchEvent 方法，所以调用的就是viewGroup类的方法了。所以到这里，事件就交给viewGroup去分发给控件树了。</p>
<p>我们来回顾一下：DecorView交给Activity处理，Activity直接交给PhoneWindow处理，PhoneWindow直接交给其内部的DecorView处理，而DecorView则直接调用父类ViewGroup的方法进行分发，ViewGroup则会按照具体的逻辑分发到整个控件树中感兴趣的子控件。关于ViewGroup如何进行分发的内容，在后续的文章继续分析。</p>
<p>从DecorView开始，绕了一圈，又回到控件树进行分发了。接下来看看Dialog是如何分发的：</p>
<h3 id="Dialog"><a href="#Dialog" class="headerlink" title="Dialog"></a>Dialog</h3><p>直接看到Dialog中的 diapatchTouchEvent 代码：<br>Dialog.java api29  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(<span class="meta">@NonNull</span> MotionEvent ev)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mWindow.superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> onTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的mWindow，就是Dialog内部维护的PhoneWindow实例，接下去的逻辑就和Activity的流程一样了，这里不再赘述。<br>而如果没有使用DecorView作为模板的窗口，流程就会和上述不一致了，例如PopupWindow：</p>
<h3 id="PopupWindow"><a href="#PopupWindow" class="headerlink" title="PopupWindow"></a>PopupWindow</h3><p>PopupWindow他的根View是 PopupDecorView ，而不是 DecorView 。虽然他的名字带有DecorView，但是却和DecorView一点关系都没有，他是直接继承于FrameLayout。我们看到他的事件分发方法：  </p>
<p>PopupWindow.java api29   </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mTouchInterceptor != <span class="literal">null</span> &amp;&amp; mTouchInterceptor.onTouch(<span class="built_in">this</span>, ev)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.dispatchTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mTouchInterceptor 是一个拦截器，我们可以手动给PopupWindow设置拦截器。时间会优先交给拦截器处理，如果没有拦截器或拦截器没有消费事件，那么才会交给viewGroup去进行分发。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后我们对整个流程进行一次回顾：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92fd8015131b42b89e5376862cce9da7~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp"></p>
<p>IMS从系统底层接收到事件之后，会从WMS中获取window信息，并将事件信息发送给对应的viewRootImpl<br>viewRootImpl接收到事件信息，封装成motionEvent对象后，发送给管理的view<br>view会根据自身的类型，对事件进行分发还是自己处理<br>顶层viewGroup一般是DecorView，DecorView会根据自身callBack的情况，选择调用callBack或者调用父类ViewGroup的方法<br>而不管顶层viewGroup的类型如何，最终都会到达ViewGroup对事件进行分发。  </p>
<p>到这里，虽然触摸事件的“去脉”我们还不清楚，但是他的“来龙”就已经非常清晰了。<br>本文的主要内容是讲事件的来源，但事件分发的来源远没有这么简单，源码的细节有非常多的内容值得我们去学习，而本文只是把整体的流程抽了出来。而其他关于系统底层的内容，对于有兴趣读者推荐一系列书籍：《深入理解androidⅠⅡⅢ》。</p>
<link rel="stylesheet" href="/css/markmap.css" type="text/css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 入门</title>
    <url>/blog/2021-06-27-Docker%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p><img src="https://www.ruanyifeng.com/blogimg/asset/2018/bg2018020901.png" alt="docker"><span id="more"></span></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="Docker-是什么"><a href="#Docker-是什么" class="headerlink" title="Docker 是什么"></a>Docker 是什么</h3><ul>
<li>应用容器引擎（Linux 容器 LXC的一种封装，提供简单易用的容器使用接口）</li>
<li>基于 Go 语言</li>
<li>开源 Apache2.0协议</li>
<li>两个版本：CE、EE</li>
<li>2013年发布</li>
</ul>
<p>Docker 将应用程序与该程序的依赖，打包在一个轻量级、可移植的文件里。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题，更重要的是容器性能开销极低。</p>
<p>Docker 的接口相当简单，用户可以方便地创建和使用容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p>
<h3 id="解决了什么问题"><a href="#解决了什么问题" class="headerlink" title="解决了什么问题"></a>解决了什么问题</h3><ul>
<li><p>环境配置的难题<br>安装一个软件，只有各种依赖（操作系统的设置、各种库和组件）的安装都正确，才能正常运行。而且每换一台机器，就要重来一次。</p>
<ul>
<li>解决方案：软件带环境安装</li>
</ul>
</li>
<li><p>Docker VS 虚拟机</p>
<ul>
<li>Docker 是进程级别的隔离（沙箱机制），而非模拟完整操作系统</li>
<li>启动快</li>
<li>冗余步骤少</li>
<li>资源占用少</li>
<li>体积小</li>
</ul>
</li>
</ul>
<h3 id="用途和应用场景"><a href="#用途和应用场景" class="headerlink" title="用途和应用场景"></a>用途和应用场景</h3><ul>
<li>提供一次性的环境</li>
<li>提供弹性的云服务</li>
<li>组建微服务架构</li>
<li>……</li>
</ul>
<h2 id="Docker-架构"><a href="#Docker-架构" class="headerlink" title="Docker 架构"></a>Docker 架构</h2><h3 id="镜像（Image）"><a href="#镜像（Image）" class="headerlink" title="镜像（Image）"></a>镜像（Image）</h3><p>Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。</p>
<p>Docker 把应用程序及其依赖，打包在 image 文件里面。只有通过这个文件（容器模板），才能生成 Docker 容器。同一个 image 文件，可以生成多个同时运行的容器实例。</p>
<p>image 是通用的跨平台二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。</p>
<h3 id="容器（Container）"><a href="#容器（Container）" class="headerlink" title="容器（Container）"></a>容器（Container）</h3><p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。</p>
<p>容器可以被创建、启动、停止、删除、暂停等。</p>
<h3 id="仓库（Respository）"><a href="#仓库（Respository）" class="headerlink" title="仓库（Respository）"></a>仓库（Respository）</h3><p>仓库可看成一个代码控制中心，用来保存镜像。</p>
<p>Docker Hub(<a href="https://hub.docker.com/">https://hub.docker.com</a>) 提供了庞大的镜像集合供使用。</p>
<p>一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。</p>
<h3 id="Docker-架构图（C-S-架构）"><a href="#Docker-架构图（C-S-架构）" class="headerlink" title="Docker 架构图（C/S 架构）"></a>Docker 架构图（C/S 架构）</h3><p><img src="https://www.runoob.com/wp-content/uploads/2016/04/576507-docker1.png" alt="Docker架构图"></p>
<ul>
<li>Docker 客户端(Client)<ul>
<li>Docker 客户端通过命令行或者其他工具使用 Docker SDK (<a href="https://docs.docker.com/develop/sdk/">https://docs.docker.com/develop/sdk/</a>) 与 Docker 的守护进程通信。</li>
</ul>
</li>
<li>Docker 主机(Host)<ul>
<li>一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。</li>
</ul>
</li>
<li>Docker Machine<ul>
<li>Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。</li>
</ul>
</li>
</ul>
<h2 id="安装和换源"><a href="#安装和换源" class="headerlink" title="安装和换源"></a>安装和换源</h2><h3 id="Ubuntu-16-0-4"><a href="#Ubuntu-16-0-4" class="headerlink" title="Ubuntu 16.0.4"></a>Ubuntu 16.0.4</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用官方脚本自动安装</span></span><br><span class="line">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证安装</span></span><br><span class="line">docker info</span><br><span class="line"></span><br><span class="line"><span class="comment"># Docker 需要用户具有 sudo 权限，为了避免每次命令都输入sudo，可以把用户加入 Docker 用户组</span></span><br><span class="line">sudo usermod -aG docker <span class="variable">$USER</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 docker 服务</span></span><br><span class="line">sudo systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 换源</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&#x27;对于使用 systemd 的系统，请在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件）：\n&#123;&quot;registry-mirrors&quot;:[&quot;https://reg-mirror.qiniu.com/&quot;]&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查加速器是否生效</span></span><br><span class="line">docker info</span><br></pre></td></tr></table></figure>

<p>国内从 DockerHub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。Docker 官方和国内很多云服务商都提供了国内加速器服务，例如：</p>
<ul>
<li>科大镜像：<a href="https://docker.mirrors.ustc.edu.cn/">https://docker.mirrors.ustc.edu.cn/</a></li>
<li>网易：<a href="https://hub-mirror.c.163.com/">https://hub-mirror.c.163.com/</a></li>
<li>阿里云：https://&lt;你的ID&gt;.mirror.aliyuncs.com</li>
<li>七牛云加速器：<a href="https://reg-mirror.qiniu.com/">https://reg-mirror.qiniu.com</a></li>
</ul>
<h3 id="其他操作系统"><a href="#其他操作系统" class="headerlink" title="其他操作系统"></a>其他操作系统</h3><ul>
<li>MacOS</li>
<li>Windows</li>
<li>CentOS</li>
<li>……</li>
</ul>
<blockquote>
<p>参考官方文档或自行搜索</p>
</blockquote>
<h2 id="Image-文件"><a href="#Image-文件" class="headerlink" title="Image 文件"></a>Image 文件</h2><h3 id="docker-image-ls"><a href="#docker-image-ls" class="headerlink" title="docker image ls"></a>docker image ls</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出本机的所有 image 文件。</span></span><br><span class="line">$ docker image <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>

<h3 id="docker-image-rm"><a href="#docker-image-rm" class="headerlink" title="docker image rm"></a>docker image rm</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除 image 文件</span></span><br><span class="line">$ docker image <span class="built_in">rm</span> [imageName]</span><br></pre></td></tr></table></figure>

<h3 id="docker-image-pull"><a href="#docker-image-pull" class="headerlink" title="docker image pull"></a>docker image pull</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从仓库拉取 image 文件。</span></span><br><span class="line">$ docker image pull [imageName]</span><br></pre></td></tr></table></figure>

<h2 id="容器文件"><a href="#容器文件" class="headerlink" title="容器文件"></a>容器文件</h2><p>image 文件生成的容器实例，本身也是一个文件，称为容器文件。</p>
<p>一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。</p>
<h3 id="docker-container-ls"><a href="#docker-container-ls" class="headerlink" title="docker container ls"></a>docker container ls</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出本机正在运行的容器</span></span><br><span class="line">$ docker container <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 列出本机所有容器，包括终止运行的容器</span></span><br><span class="line">$ docker container <span class="built_in">ls</span> --all</span><br></pre></td></tr></table></figure>

<h3 id="docker-container-run"><a href="#docker-container-run" class="headerlink" title="docker container run"></a>docker container run</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 运行容器</span></span><br><span class="line">$ docker container run [imageName]</span><br></pre></td></tr></table></figure>
<p>docker container run命令具有自动抓取 image 文件的功能。如果发现本地没有指定的 image 文件，就会从仓库自动抓取。</p>
<h3 id="docker-container-kill"><a href="#docker-container-kill" class="headerlink" title="docker container kill"></a>docker container kill</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 终止容器运行</span></span><br><span class="line">$ docker container <span class="built_in">kill</span> [containID]</span><br></pre></td></tr></table></figure>

<h3 id="docker-container-rm"><a href="#docker-container-rm" class="headerlink" title="docker container rm"></a>docker container rm</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除容器实例</span></span><br><span class="line">$ docker container <span class="built_in">rm</span> [containerID]</span><br></pre></td></tr></table></figure>

<h2 id="Dockerfile-文件"><a href="#Dockerfile-文件" class="headerlink" title="Dockerfile 文件"></a>Dockerfile 文件</h2><p>它是一个文本文件，用来配置 image。Docker 根据 该文件生成二进制的 image 文件。</p>
<h3 id="dockerignore"><a href="#dockerignore" class="headerlink" title=".dockerignore"></a>.dockerignore</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.git</span><br><span class="line">node_modules</span><br><span class="line">npm-debug.log</span><br></pre></td></tr></table></figure>
<p>上面代码表示，这三个路径要排除，不要打包进入 image 文件。</p>
<h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">8.4</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . /app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> npm install --registry=https://registry.npm.taobao.org</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3000</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> node demos/01.js</span></span><br></pre></td></tr></table></figure>
<ul>
<li>FROM node:8.4：<ul>
<li>该 image 文件继承官方的 node image，冒号表示标签，这里标签是8.4，即8.4版本的 node。</li>
</ul>
</li>
<li>COPY . /app：<ul>
<li>将当前目录下的所有文件（除了.dockerignore排除的路径），都拷贝进入 image 文件的/app目录。</li>
</ul>
</li>
<li>WORKDIR /app：<ul>
<li>指定接下来的工作路径为/app。</li>
</ul>
</li>
<li>RUN npm install：<ul>
<li>在/app目录下，运行npm install命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。</li>
</ul>
</li>
<li>EXPOSE 3000：<ul>
<li>将容器 3000 端口暴露出来， 允许外部连接这个端口。</li>
</ul>
</li>
<li>CMD node demos/01.js：<ul>
<li>它表示容器启动后自动执行node demos/01.js。</li>
</ul>
</li>
</ul>
<p>RUN命令与CMD命令的区别在哪里？</p>
<ul>
<li>RUN命令在 image 文件的构建阶段执行，执行结果都会打包进入 image 文件；CMD命令则是在容器启动后执行。</li>
<li>一个 Dockerfile 可以包含多个RUN命令，但是只能有一个CMD命令。</li>
</ul>
<h3 id="创建-Image-文件"><a href="#创建-Image-文件" class="headerlink" title="创建 Image 文件"></a>创建 Image 文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image build -t koa-demo .</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ docker image build -t koa-demo:0.0.1 .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果运行成功，就可以看到新生成的 image 文件</span></span><br><span class="line">$ docker image <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>

<h3 id="生成并运行容器"><a href="#生成并运行容器" class="headerlink" title="生成并运行容器"></a>生成并运行容器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker container run -p 8000:3000 -it koa-demo /bin/bash</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ docker container run -p 8000:3000 -it koa-demo:0.0.1 /bin/bash</span><br><span class="line"><span class="comment"># 指定了CMD命令以后，docker container run命令就不能附加命令了（比如前面的/bin/bash），否则它会覆盖CMD命令。</span></span><br><span class="line">$ docker container run --<span class="built_in">rm</span> -p 8000:3000 -it koa-demo:0.0.1</span><br></pre></td></tr></table></figure>
<ul>
<li>-p参数：<ul>
<li>容器的 3000 端口映射到本机的 8000 端口。</li>
</ul>
</li>
<li>-it参数：<ul>
<li>容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。</li>
</ul>
</li>
<li>koa-demo:0.0.1：<ul>
<li>image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。</li>
</ul>
</li>
<li>/bin/bash：<ul>
<li>容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。</li>
</ul>
</li>
</ul>
<h2 id="发布-Image-文件"><a href="#发布-Image-文件" class="headerlink" title="发布 Image 文件"></a>发布 Image 文件</h2><p>首先，去 hub.docker.com 或 cloud.docker.com 注册一个账户。然后，用下面的命令登录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker login</span><br></pre></td></tr></table></figure>
<p>接着，为本地的 image 标注用户名和版本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image tag [imageName] [username]/[repository]:[tag]</span><br><span class="line"><span class="comment"># 实例</span></span><br><span class="line">$ docker image tag koa-demos:0.0.1 ruanyf/koa-demos:0.0.1</span><br></pre></td></tr></table></figure>
<p>也可以不标注用户名，重新构建一下 image 文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image build -t [username]/[repository]:[tag] .</span><br></pre></td></tr></table></figure>
<p>最后，发布 image 文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image push [username]/[repository]:[tag]</span><br></pre></td></tr></table></figure>
<p>发布成功以后，登录 hub.docker.com，就可以看到已经发布的 image 文件。</p>
<h2 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h2><h3 id="docker-container-start"><a href="#docker-container-start" class="headerlink" title="docker container start"></a>docker container start</h3><p>前面的docker container run命令是新建容器，每运行一次，就会新建一个容器。如果希望重复使用容器，就要使用docker container start命令，它用来启动已经生成、已经停止运行的容器文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker container start [containerID]</span><br></pre></td></tr></table></figure>

<h3 id="docker-container-stop"><a href="#docker-container-stop" class="headerlink" title="docker container stop"></a>docker container stop</h3><p>前面的docker container kill命令终止容器运行，相当于向容器里面的主进程发出 SIGKILL 信号。而docker container stop命令也是用来终止容器运行，相当于向容器里面的主进程发出 SIGTERM 信号，然后过一段时间再发出 SIGKILL 信号。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker container stop [containerID]</span><br></pre></td></tr></table></figure>
<p>这两个信号的差别是，应用程序收到 SIGTERM 信号以后，可以自行进行收尾清理工作，但也可以不理会这个信号。如果收到 SIGKILL 信号，就会强行立即终止，那些正在进行中的操作会全部丢失。</p>
<h3 id="docker-container-logs"><a href="#docker-container-logs" class="headerlink" title="docker container logs"></a>docker container logs</h3><p>docker container logs命令用来查看 docker 容器的输出，即容器里面 Shell 的标准输出。如果docker run命令运行容器的时候，没有使用-it参数，就要用这个命令查看输出。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker container logs [containerID]</span><br></pre></td></tr></table></figure>

<h3 id="docker-container-exec"><a href="#docker-container-exec" class="headerlink" title="docker container exec"></a>docker container exec</h3><p>docker container exec命令用于进入一个正在运行的 docker 容器。如果docker run命令运行容器的时候，没有使用-it参数，就要用这个命令进入容器。一旦进入了容器，就可以在容器的 Shell 执行命令了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker container <span class="built_in">exec</span> -it [containerID] /bin/bash</span><br></pre></td></tr></table></figure>

<h3 id="docker-container-cp"><a href="#docker-container-cp" class="headerlink" title="docker container cp"></a>docker container cp</h3><p>docker container cp命令用于从正在运行的 Docker 容器里面，将文件拷贝到本机。下面是拷贝到当前目录的写法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker container <span class="built_in">cp</span> [containID]:[/path/to/file] .</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/markmap.css" type="text/css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>ReactNative Metro 打包浅析</title>
    <url>/blog/2020-06-02-RN%20metro/</url>
    <content><![CDATA[<h2 id="Metro是什么"><a href="#Metro是什么" class="headerlink" title="Metro是什么"></a>Metro是什么</h2><p>metro 是一个针对 React Native的JavaScript模块打包器，他接收一个entry file (入口文件) 和一些配置作为参数，返回给你一个单独的JavaScript文件，这个文件包含了你写的所有的JavaScript 代码和所有的依赖。</p>
<p>也就是说Metro把你写的几十上百个js文件和几百个node_modules的依赖，打包成了一个文件。<span id="more"></span></p>
<h2 id="Metro的工作原理"><a href="#Metro的工作原理" class="headerlink" title="Metro的工作原理"></a>Metro的工作原理</h2><p>Metro 的打包过程有3个独立的阶段</p>
<p>Resolution<br>Transformation<br>Serialization  </p>
<h3 id="Resolution-阶段"><a href="#Resolution-阶段" class="headerlink" title="Resolution 阶段"></a>Resolution 阶段</h3><p>Metro 需要建立一个你的入口文件所需要的所有的模块的表，为了找到一个文件依赖了哪些文件，Metro 使用了一个resolver。在实际中，Resolution阶段是和transformation阶段并行进行的。</p>
<h3 id="Transformation阶段"><a href="#Transformation阶段" class="headerlink" title="Transformation阶段"></a>Transformation阶段</h3><p>所有的模块都要经历一个 transformer， transformer 负责把一个模块转换成RN能理解的格式；</p>
<h3 id="Serialization阶段"><a href="#Serialization阶段" class="headerlink" title="Serialization阶段"></a>Serialization阶段</h3><p>一旦模块被转换完成，就会马上被serialized，通过serializer，把上一个阶段转换好的模块组合成一个或多个bundle，bundle 就是字面意思：把一堆模块组合成一个单独的JavaScript文件</p>
<p>Metro这个库已经根据bundle时的各个阶段，拆分为resolver,transformer,serializer 模块了，每个模块负责相应的功能，因此你可以方便的替换为自己的模块。</p>
<h2 id="RAM-bundle"><a href="#RAM-bundle" class="headerlink" title="RAM bundle"></a>RAM bundle</h2><p>即： Random Access Modules (RAM) bundle<br>当 Metro在bundle的时候，每个模块都被分配了一个数字的id，这意味着Metro不支持动态的require；<br>Requires 随着数字的版本而改变，从而modules 被分成了不同的形式，目前支持3种不同形式的bundling  </p>
<p>Plain bundle<br>这是标准的bundling 形式，所有的文件是通过一个立即执行函数包裹，然后加到global file 中，这中形式对于一些期望JS only bundle的环境（比如浏览器环境）是很有用的；用.bundle后缀来 requiring 入口文件就会触发一个Plain bundle的构建</p>
<p>Indexed RAM bundle<br>这种形式是把bundle变成了二进制文件，文件一般由以下部分组成：</p>
<p>A magic number：文件的开头必须是一个uint32，他的值是0xFB0BD1E5，这个用于验证文件；</p>
<p>An offset table：这个table是一系列的uint32 pairs，还带有一个header</p>
<p>header：header是2个uint32，一个指示了这个table的长度，另一个指示了startup code的长度</p>
<p>pairs：他们以bytes的形式指示了文件的offset，模块的长度</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">` 0                   1                   2                   3                   4                   5                   6</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                          Magic number                         |                          Header size                          |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                       Startup code size                       |                        Module 0 offset                        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                        Module 0 length                        |                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                                                               +</span><br><span class="line">|                                                                                                                               |</span><br><span class="line">+                                                              ...                                                              +</span><br><span class="line">|                                                                                                                               |</span><br><span class="line">+                                                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               |                        Module n offset                        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                        Module n length                        | Module 0 code | Module 0 code |      ...      |       \0      |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">| Module 1 code | Module 1 code |      ...      |       \0      |                                                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                                                               +</span><br><span class="line">|                                                                                                                               |</span><br><span class="line">+                                                              ...                                                              +</span><br><span class="line">|                                                                                                                               |</span><br><span class="line">+                                                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                                                               | Module n code | Module n code |      ...      |       \0      |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+`</span><br></pre></td></tr></table></figure>

<p>通过使用offset table，我们可以在固定时间内加载任意的module：比如module x 位于 file[(x + 3) * sizeof(uint32)]，由于模块是通过\0来区分开的，一般情况下甚至不需要使用length，module能直接以ASCIIZ string 的方式加载<br>Startup code 总是在 file[sizeof(uint32)]<br>这种结构对于可以一次把所有代码加载到内存的环境是最佳的；这种bundling通常用于 iOS端</p>
<p>File RAM bundle  </p>
<p>每个模块都被保存为名为 js-modules/${id}.js的文件，另外还创建了一个名为UNBUNDLE的文件，内容只包含magic number：0xFB0BD1E5，注意 UNBUNDLE文件位于根目录下，这种bundling通常用于Android端，因为package contents 被压缩了，Android 加载压缩文件十分快，如果使用 indexed format，所有的bundled需要一次性被解压出来才能获取到对于模块的代码</p>
<h2 id="如何开启RAM-bundle"><a href="#如何开启RAM-bundle" class="headerlink" title="如何开启RAM bundle"></a>如何开启RAM bundle</h2><p>默认情况下，打包的bundle是 Plain bundle，后面的2种RAM bundle的形式是高级用法。<br>使用方法见文档：enable-the-ram-format</p>
<link rel="stylesheet" href="/css/markmap.css" type="text/css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title>React Hook 再探索</title>
    <url>/blog/2020-09-15-React%20hook2/</url>
    <content><![CDATA[<p>最近逐渐体会到 React 钩子（hooks）非常好用，感觉重新认识了 React 这个框架。</p>
<p>下面就来谈谈，怎样正确理解钩子，并且深入剖析最重要的钩子之一的useEffect()。内容会尽量通俗，让不熟悉 React 的朋友也能看懂。</p>
<h2 id="一、React-的两套-API"><a href="#一、React-的两套-API" class="headerlink" title="一、React 的两套 API"></a>一、React 的两套 API</h2><p>以前，React API 只有一套，现在有两套：类（class）API 和基于函数的钩子（hooks） API。<span id="more"></span></p>
<p>任何一个组件，可以用类来写，也可以用钩子来写。下面是类的写法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Welcome</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来看钩子的写法，也就是函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Welcome</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两种写法，作用完全一样。初学者自然会问：”我应该使用哪一套 API？”</p>
<p>官方推荐使用钩子（函数），而不是类。因为钩子更简洁，代码量少，用起来比较”轻”，而类比较”重”。而且，钩子是函数，更符合 React 函数式的本质。</p>
<p>下面是类组件（左边）和函数组件（右边）代码量的比较。对于复杂的组件，差的就更多。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/202009/bg2020091320.jpg"></p>
<p>但是，钩子的灵活性太大，初学者不太容易理解。很多人一知半解，很容易写出混乱不堪、无法维护的代码。那就不如使用类了。因为类有很多强制的语法约束，不容易搞乱。</p>
<h2 id="二、类和函数的差异"><a href="#二、类和函数的差异" class="headerlink" title="二、类和函数的差异"></a>二、类和函数的差异</h2><p>严格地说，类组件和函数组件是有差异的。不同的写法，代表了不同的编程方法论。</p>
<p>类（class）是数据和逻辑的封装。 也就是说，组件的状态和操作方法是封装在一起的。如果选择了类的写法，就应该把相关的数据和操作，都写在同一个 class 里面。</p>
<p>函数一般来说，只应该做一件事，就是返回一个值。 如果你有多个操作，每个操作应该写成一个单独的函数。而且，数据的状态应该与操作方法分离。根据这种理念，React 的函数组件只应该做一件事情：返回组件的 HTML 代码，而没有其他的功能。</p>
<p>还是以上面的函数组件为例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Welcome</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数只做一件事，就是根据输入的参数，返回组件的 HTML 代码。这种只进行单纯的数据计算（换算）的函数，在函数式编程里面称为 “纯函数”（pure function）。</p>
<h2 id="三、副效应是什么？"><a href="#三、副效应是什么？" class="headerlink" title="三、副效应是什么？"></a>三、副效应是什么？</h2><p>看到这里，你可能会产生一个疑问：如果纯函数只能进行数据计算，那些不涉及计算的操作（比如生成日志、储存数据、改变应用状态等等）应该写在哪里呢？</p>
<p>函数式编程将那些跟数据计算无关的操作，都称为 “副效应” （side effect） 。如果函数内部直接包含产生副效应的操作，就不再是纯函数了，我们称之为不纯的函数。</p>
<p>纯函数内部只有通过间接的手段（即通过其他函数调用），才能包含副效应。</p>
<h2 id="四、钩子（hook）的作用"><a href="#四、钩子（hook）的作用" class="headerlink" title="四、钩子（hook）的作用"></a>四、钩子（hook）的作用</h2><p>说了半天，那么钩子到底是什么？</p>
<p>一句话，钩子（hook）就是 React 函数组件的副效应解决方案，用来为函数组件引入副效应。 函数组件的主体只应该用来返回组件的 HTML 代码，所有的其他操作（副效应）都必须通过钩子引入。</p>
<p>由于副效应非常多，所以钩子有许多种。React 为许多常见的操作（副效应），都提供了专用的钩子。</p>
<p>useState()：保存状态<br>useContext()：保存上下文<br>useRef()：保存引用<br>……<br>上面这些钩子，都是引入某种特定的副效应，而 useEffect()是通用的副效应钩子 。找不到对应的钩子时，就可以用它。其实，从名字也可以看出来，它跟副效应（side effect）直接相关。</p>
<h2 id="五、useEffect-的用法"><a href="#五、useEffect-的用法" class="headerlink" title="五、useEffect() 的用法"></a>五、useEffect() 的用法</h2><p>useEffect()本身是一个函数，由 React 框架提供，在函数组件内部调用即可。</p>
<p>举例来说，我们希望组件加载以后，网页标题（document.title）会随之改变。那么，改变网页标题这个操作，就是组件的副效应，必须通过useEffect()来实现。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Welcome</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&#x27;加载完成&#x27;</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面例子中，useEffect()的参数是一个函数，它就是所要完成的副效应（改变网页标题）。组件加载以后，React 就会执行这个函数。（查看运行结果）</p>
<p>useEffect()的作用就是指定一个副效应函数，组件每渲染一次，该函数就自动执行一次。组件首次在网页 DOM 加载后，副效应函数也会执行。</p>
<h2 id="六、useEffect-的第二个参数"><a href="#六、useEffect-的第二个参数" class="headerlink" title="六、useEffect() 的第二个参数"></a>六、useEffect() 的第二个参数</h2><p>有时候，我们不希望useEffect()每次渲染都执行，这时可以使用它的第二个参数，使用一个数组指定副效应函数的依赖项，只有依赖项发生变化，才会重新渲染。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Welcome</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">`Hello, <span class="subst">$&#123;props.name&#125;</span>`</span>;</span><br><span class="line">  &#125;, [props.<span class="property">name</span>]);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面例子中，useEffect()的第二个参数是一个数组，指定了第一个参数（副效应函数）的依赖项（props.name）。只有该变量发生变化时，副效应函数才会执行。</p>
<p>如果第二个参数是一个空数组，就表明副效应参数没有任何依赖项。因此，副效应函数这时只会在组件加载进入 DOM 后执行一次，后面组件重新渲染，就不会再次执行。这很合理，由于副效应不依赖任何变量，所以那些变量无论怎么变，副效应函数的执行结果都不会改变，所以运行一次就够了。</p>
<h2 id="七、useEffect-的用途"><a href="#七、useEffect-的用途" class="headerlink" title="七、useEffect() 的用途"></a>七、useEffect() 的用途</h2><p>只要是副效应，都可以使用useEffect()引入。它的常见用途有下面几种。</p>
<p>获取数据（data fetching）<br>事件监听或订阅（setting up a subscription）<br>改变 DOM（changing the DOM）<br>输出日志（logging）<br>下面是从远程服务器获取数据的例子。（查看运行结果）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = <span class="title function_">useState</span>(&#123; <span class="attr">hits</span>: [] &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">fetchData</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">axios</span>(</span><br><span class="line">        <span class="string">&#x27;https://hn.algolia.com/api/v1/search?query=redux&#x27;</span>,</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      <span class="title function_">setData</span>(result.<span class="property">data</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">fetchData</span>();</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;data.hits.map(item =&gt; (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;item.objectID&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#123;item.url&#125;</span>&gt;</span>&#123;item.title&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      ))&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure>

<p>上面例子中，useState()用来生成一个状态变量（data），保存获取的数据；useEffect()的副效应函数内部有一个 async 函数，用来从服务器异步获取数据。拿到数据以后，再用setData()触发组件的重新渲染。</p>
<p>由于获取数据只需要执行一次，所以上例的useEffect()的第二个参数为一个空数组。</p>
<h2 id="八、useEffect-的返回值"><a href="#八、useEffect-的返回值" class="headerlink" title="八、useEffect() 的返回值"></a>八、useEffect() 的返回值</h2><p>副效应是随着组件加载而发生的，那么组件卸载时，可能需要清理这些副效应。</p>
<p>useEffect()允许返回一个函数，在组件卸载时，执行该函数，清理副效应。如果不需要清理副效应，useEffect()就不用返回任何值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> subscription = props.<span class="property">source</span>.<span class="title function_">subscribe</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    subscription.<span class="title function_">unsubscribe</span>();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, [props.<span class="property">source</span>]);</span><br></pre></td></tr></table></figure>

<p>上面例子中，useEffect()在组件加载时订阅了一个事件，并且返回一个清理函数，在组件卸载时取消订阅。</p>
<p>实际使用中，由于副效应函数默认是每次渲染都会执行，所以清理函数不仅会在组件卸载时执行一次，每次副效应函数重新执行之前，也会执行一次，用来清理上一次渲染的副效应。</p>
<h2 id="九、useEffect-的注意点"><a href="#九、useEffect-的注意点" class="headerlink" title="九、useEffect() 的注意点"></a>九、useEffect() 的注意点</h2><p>使用useEffect()时，有一点需要注意。如果有多个副效应，应该调用多个useEffect()，而不应该合并写在一起。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [varA, setVarA] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [varB, setVarB] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> timeoutA = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">setVarA</span>(varA + <span class="number">1</span>), <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">const</span> timeoutB = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">setVarB</span>(varB + <span class="number">2</span>), <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timeoutA);</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timeoutB);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, [varA, varB]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;varA&#125;, &#123;varB&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子是错误的写法，副效应函数里面有两个定时器，它们之间并没有关系，其实是两个不相关的副效应，不应该写在一起。正确的写法是将它们分开写成两个useEffect()。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [varA, setVarA] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [varB, setVarB] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">setVarA</span>(varA + <span class="number">1</span>), <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">  &#125;, [varA]);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">setVarB</span>(varB + <span class="number">2</span>), <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">  &#125;, [varB]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;varA&#125;, &#123;varB&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（正文完）</p>
<link rel="stylesheet" href="/css/markmap.css" type="text/css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React Hook 入门</title>
    <url>/blog/2019-09-01-React%20hook1/</url>
    <content><![CDATA[<p>React 是主流的前端框架，v16.8 版本引入了全新的 API，叫做 React Hooks，颠覆了以前的用法。</p>
<p>这个 API 是 React 的未来，有必要深入理解。本文谈谈我的理解，简单介绍它的用法，帮助大家快速上手。</p>
<p>阅读本文需要有 React 基础。如果你还没学会 React，可以先看一下它的教程。</p>
<h2 id="一、组件类的缺点"><a href="#一、组件类的缺点" class="headerlink" title="一、组件类的缺点"></a>一、组件类的缺点</h2><p>React 的核心是组件。v16.8 版本之前，组件的标准写法是类（class）。下面是一个简单的组件类。 <span id="more"></span></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Button</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">buttonText</span>: <span class="string">&quot;Click me, please&quot;</span> &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleClick</span> = <span class="variable language_">this</span>.<span class="property">handleClick</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">buttonText</span>: <span class="string">&quot;Thanks, been clicked!&quot;</span> &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; buttonText &#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>&#123;buttonText&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个组件类仅仅是一个按钮，但可以看到，它的代码已经很”重”了。真实的 React App 由多个类按照层级，一层层构成，复杂度成倍增长。再加入 Redux，就变得更复杂。</p>
<p>Redux 的作者 Dan Abramov 总结了组件类的几个缺点。</p>
<p>大型组件很难拆分和重构，也很难测试。<br>业务逻辑分散在组件的各个方法之中，导致重复逻辑或关联逻辑。<br>组件类引入了复杂的编程模式，比如 render props 和高阶组件。  </p>
<h2 id="二、函数组件"><a href="#二、函数组件" class="headerlink" title="二、函数组件"></a>二、函数组件</h2><p>React 团队希望，组件不要变成复杂的容器，最好只是数据流的管道。开发者根据需要，组合管道即可。 组件的最佳写法应该是函数，而不是类。</p>
<p>React 早就支持函数组件，下面就是一个例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Welcome</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，这种写法有重大限制，必须是纯函数，不能包含状态，也不支持生命周期方法，因此无法取代类。</p>
<p>React Hooks 的设计目的，就是加强版函数组件，完全不使用”类”，就能写出一个全功能的组件。</p>
<h2 id="三、Hook-的含义"><a href="#三、Hook-的含义" class="headerlink" title="三、Hook 的含义"></a>三、Hook 的含义</h2><p>Hook 这个单词的意思是”钩子”。</p>
<p>React Hooks 的意思是，组件尽量写成纯函数，如果需要外部功能和副作用，就用钩子把外部代码”钩”进来。 React Hooks 就是那些钩子。</p>
<p>你需要什么功能，就使用什么钩子。React 默认提供了一些常用钩子，你也可以封装自己的钩子。</p>
<p>所有的钩子都是为函数引入外部功能，所以 React 约定，钩子一律使用use前缀命名，便于识别。你要使用 xxx 功能，钩子就命名为 usexxx。</p>
<p>下面介绍 React 默认提供的四个最常用的钩子。</p>
<p>useState()<br>useContext()<br>useReducer()<br>useEffect()  </p>
<h2 id="四、useState-：状态钩子"><a href="#四、useState-：状态钩子" class="headerlink" title="四、useState()：状态钩子"></a>四、useState()：状态钩子</h2><p>useState()用于为函数组件引入状态（state）。纯函数不能有状态，所以把状态放在钩子里面。</p>
<p>本文前面那个组件类，用户点击按钮，会导致按钮的文字改变，文字取决于用户是否点击，这就是状态。使用useState()重写如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>  <span class="title function_">Button</span>(<span class="params"></span>)  &#123;</span><br><span class="line">  <span class="keyword">const</span>  [buttonText, setButtonText] =  <span class="title function_">useState</span>(<span class="string">&quot;Click me,   please&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">handleClick</span>(<span class="params"></span>)  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">setButtonText</span>(<span class="string">&quot;Thanks, been clicked!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span>  <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>&#123;buttonText&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，Button 组件是一个函数，内部使用useState()钩子引入状态。</p>
<p>useState()这个函数接受状态的初始值，作为参数，上例的初始值为按钮的文字。该函数返回一个数组，数组的第一个成员是一个变量（上例是buttonText），指向状态的当前值。第二个成员是一个函数，用来更新状态，约定是set前缀加上状态的变量名（上例是setButtonText）。</p>
<h2 id="五、useContext-：共享状态钩子"><a href="#五、useContext-：共享状态钩子" class="headerlink" title="五、useContext()：共享状态钩子"></a>五、useContext()：共享状态钩子</h2><p>如果需要在组件之间共享状态，可以使用useContext()。</p>
<p>现在有两个组件 Navbar 和 Messages，我们希望它们之间共享状态。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div className=<span class="string">&quot;App&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Navbar</span>/&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Messages</span>/&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>第一步就是使用 React Context API，在组件外部建立一个 Context。</p>
<p>const AppContext = React.createContext({});<br>组件封装代码如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">AppContext</span>.<span class="property">Provider</span> value=&#123;&#123;</span><br><span class="line">  <span class="attr">username</span>: <span class="string">&#x27;superawesome&#x27;</span></span><br><span class="line">&#125;&#125;&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Navbar</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Messages</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">AppContext</span>.<span class="property">Provider</span>&gt;</span><br></pre></td></tr></table></figure>

<p>上面代码中，AppContext.Provider提供了一个 Context 对象，这个对象可以被子组件共享。</p>
<p>Navbar 组件的代码如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Navbar</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; username &#125; = <span class="title function_">useContext</span>(<span class="title class_">AppContext</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;navbar&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>AwesomeSite<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;username&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，useContext()钩子函数用来引入 Context 对象，从中获取username属性。</p>
<p>Message 组件的代码也类似。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Messages</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; username &#125; = <span class="title function_">useContext</span>(<span class="title class_">AppContext</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;messages&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Messages<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>1 message for &#123;username&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">&quot;message&quot;</span>&gt;</span>useContext is awesome!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六、useReducer-：action-钩子"><a href="#六、useReducer-：action-钩子" class="headerlink" title="六、useReducer()：action 钩子"></a>六、useReducer()：action 钩子</h2><p>React 本身不提供状态管理功能，通常需要使用外部库。这方面最常用的库是 Redux。</p>
<p>Redux 的核心概念是，组件发出 action 与状态管理器通信。状态管理器收到 action 以后，使用 Reducer 函数算出新的状态，Reducer 函数的形式是(state, action) =&gt; newState。</p>
<p>useReducers()钩子用来引入 Reducer 功能。</p>
<p>const [state, dispatch] = useReducer(reducer, initialState);<br>上面是useReducer()的基本用法，它接受 Reducer 函数和状态的初始值作为参数，返回一个数组。数组的第一个成员是状态的当前值，第二个成员是发送 action 的dispatch函数。</p>
<p>下面是一个计数器的例子。用于计算状态的 Reducer 函数如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">myReducer</span> = (<span class="params">state, action</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span>(action.<span class="property">type</span>)  &#123;</span><br><span class="line">    <span class="keyword">case</span>(<span class="string">&#x27;countUp&#x27;</span>):</span><br><span class="line">      <span class="keyword">return</span>  &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        <span class="attr">count</span>: state.<span class="property">count</span> + <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span>  state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组件代码如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = <span class="title function_">useReducer</span>(myReducer, &#123; <span class="attr">count</span>:   <span class="number">0</span> &#125;);</span><br><span class="line">  <span class="keyword">return</span>  (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;countUp&#x27; &#125;)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        +1</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;state.count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 Hooks 可以提供共享状态和 Reducer 函数，所以它在这些方面可以取代 Redux。但是，它没法提供中间件（middleware）和时间旅行（time travel），如果你需要这两个功能，还是要用 Redux。</p>
<h2 id="七、useEffect-：副作用钩子"><a href="#七、useEffect-：副作用钩子" class="headerlink" title="七、useEffect()：副作用钩子"></a>七、useEffect()：副作用钩子</h2><p>useEffect()用来引入具有副作用的操作，最常见的就是向服务器请求数据。以前，放在componentDidMount里面的代码，现在可以放在useEffect()。</p>
<p>useEffect()的用法如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">()  =&gt;</span>  &#123;</span><br><span class="line">  <span class="comment">// Async Action</span></span><br><span class="line">&#125;, [dependencies])</span><br></pre></td></tr></table></figure>

<p>上面用法中，useEffect()接受两个参数。第一个参数是一个函数，异步操作的代码放在里面。第二个参数是一个数组，用于给出 Effect 的依赖项，只要这个数组发生变化，useEffect()就会执行。第二个参数可以省略，这时每次组件渲染时，就会执行useEffect()。</p>
<p>下面看一个例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Person</span> = (<span class="params">&#123; personId &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [loading, setLoading] = <span class="title function_">useState</span>(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">const</span> [person, setPerson] = <span class="title function_">useState</span>(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setLoading</span>(<span class="literal">true</span>); </span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">`https://swapi.co/api/people/<span class="subst">$&#123;personId&#125;</span>/`</span>)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">setPerson</span>(data);</span><br><span class="line">        <span class="title function_">setLoading</span>(<span class="literal">false</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;, [personId])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (loading === <span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Loading ...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>You&#x27;re viewing: &#123;person.name&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Height: &#123;person.height&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Mass: &#123;person.mass&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，每当组件参数personId发生变化，useEffect()就会执行。组件第一次渲染时，useEffect()也会执行。</p>
<h2 id="八、创建自己的-Hooks"><a href="#八、创建自己的-Hooks" class="headerlink" title="八、创建自己的 Hooks"></a>八、创建自己的 Hooks</h2><p>上例的 Hooks 代码还可以封装起来，变成一个自定义的 Hook，便于共享。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">usePerson</span> = (<span class="params">personId</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [loading, setLoading] = <span class="title function_">useState</span>(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">const</span> [person, setPerson] = <span class="title function_">useState</span>(&#123;&#125;);</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setLoading</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">`https://swapi.co/api/people/<span class="subst">$&#123;personId&#125;</span>/`</span>)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">setPerson</span>(data);</span><br><span class="line">        <span class="title function_">setLoading</span>(<span class="literal">false</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;, [personId]);  </span><br><span class="line">  <span class="keyword">return</span> [loading, person];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，usePerson()就是一个自定义的 Hook。</p>
<p>Person 组件就改用这个新的钩子，引入封装的逻辑。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Person</span> = (<span class="params">&#123; personId &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [loading, person] = <span class="title function_">usePerson</span>(personId);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (loading === <span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Loading ...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>You&#x27;re viewing: &#123;person.name&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Height: &#123;person.height&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Mass: &#123;person.mass&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>（完）</p>
<link rel="stylesheet" href="/css/markmap.css" type="text/css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>JS侦测手机浏览器的几种方法</title>
    <url>/blog/2021-09-29-js%E4%BE%A6%E6%B5%8B%E6%89%8B%E6%9C%BA%E6%B5%8F%E8%A7%88%E5%99%A8/</url>
    <content><![CDATA[<p>有时候，前端网页需要知道，用户使用的是手机浏览器还是桌面浏览器。</p>
<p>本文根据 StackOverflow，整理了 JavaScript 侦测手机浏览器的五种方法。</p>
<h2 id="一、navigator-userAgent"><a href="#一、navigator-userAgent" class="headerlink" title="一、navigator.userAgent"></a>一、navigator.userAgent</h2><p>最简单的方法就是分析浏览器的 user agent 字符串，它包含了设备信息。<span id="more"></span></p>
<p>JS 通过navigator.userAgent属性拿到这个字符串，只要里面包含mobi、android、iphone等关键字，就可以认定是移动设备。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="regexp">/Mobi|Android|iPhone/i</span>.<span class="title function_">test</span>(navigator.<span class="property">userAgent</span>)) &#123;</span><br><span class="line">  <span class="comment">// 当前设备是移动设备</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"><span class="keyword">if</span> (</span><br><span class="line">  navigator.<span class="property">userAgent</span>.<span class="title function_">match</span>(<span class="regexp">/Mobi/i</span>) ||</span><br><span class="line">  navigator.<span class="property">userAgent</span>.<span class="title function_">match</span>(<span class="regexp">/Android/i</span>) ||</span><br><span class="line">  navigator.<span class="property">userAgent</span>.<span class="title function_">match</span>(<span class="regexp">/iPhone/i</span>)</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="comment">// 当前设备是移动设备</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法的优点是简单方便，缺点是不可靠，因为用户可以修改这个字符串，让手机浏览器伪装成桌面浏览器。</p>
<p>Chromium 系的浏览器，还有一个navigator.userAgentData属性，也是类似的作用。不同之处是它将 user agent 字符串解析为一个对象，该对象的mobile属性，返回一个布尔值，表示用户是否使用移动设备。</p>
<p>const isMobile = navigator.userAgentData.mobile;<br>注意，苹果的 Safari 浏览器和 Firefox 浏览器都不支持这个属性，具体情况可以查看 Caniuse 网站。</p>
<p>此外，还有一个已经废除的navigator.platform属性，所有浏览器都支持，所以也可以用。它返回一个字符串，表示用户的操作系统。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="regexp">/Android|iPhone|iPad|iPod/i</span>.<span class="title function_">test</span>(navigator.<span class="property">platform</span>)) &#123;</span><br><span class="line">  <span class="comment">// 当前设备是移动设备</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、window-screen，window-innerWidth"><a href="#二、window-screen，window-innerWidth" class="headerlink" title="二、window.screen，window.innerWidth"></a>二、window.screen，window.innerWidth</h2><p>另一种方法是通过屏幕宽度，判断是否为手机。</p>
<p>window.screen对象返回用户设备的屏幕信息，该对象的width属性是屏幕宽度（单位为像素）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">screen</span>.<span class="property">width</span> &lt; <span class="number">500</span>) &#123;</span><br><span class="line">  <span class="comment">// 当前设备是移动设备 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，如果屏幕宽度window.screen.width小于500像素，就认为是手机。</p>
<p>这个方法的缺点在于，如果手机横屏使用，就识别不了。</p>
<p>另一个属性window.innerWidth返回浏览器窗口里面的网页可见部分的宽度，比较适合指定网页在不同宽度下的样式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getBrowserWidth = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">innerWidth</span> &lt; <span class="number">768</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;xs&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">innerWidth</span> &lt; <span class="number">991</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;sm&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">innerWidth</span> &lt; <span class="number">1199</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;md&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;lg&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="三、window-orientation"><a href="#三、window-orientation" class="headerlink" title="三、window.orientation"></a>三、window.orientation</h2><p>第三种方法是侦测屏幕方向，手机屏幕可以随时改变方向（横屏或竖屏），桌面设备做不到。</p>
<p>window.orientation属性用于获取屏幕的当前方向，只有移动设备才有这个属性，桌面设备会返回undefined。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">window</span>.<span class="property">orientation</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">  <span class="comment">// 当前设备是移动设备 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，iPhone 的 Safari 浏览器不支持该属性。</p>
<h2 id="四、touch-事件"><a href="#四、touch-事件" class="headerlink" title="四、touch 事件"></a>四、touch 事件</h2><p>第四种方法是，手机浏览器的 DOM 元素可以通过ontouchstart属性，为touch事件指定监听函数。桌面设备没有这个属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isMobile</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="keyword">return</span> (<span class="string">&#x27;ontouchstart&#x27;</span> <span class="keyword">in</span> <span class="variable language_">document</span>.<span class="property">documentElement</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isMobile</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">createEvent</span>(<span class="string">&quot;TouchEvent&quot;</span>); <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、window-matchMedia"><a href="#五、window-matchMedia" class="headerlink" title="五、window.matchMedia()"></a>五、window.matchMedia()</h2><p>最后一种方法是结合 CSS 来判断。</p>
<p>CSS 通过 media query（媒介查询）为网页指定响应式样式。如果某个针对手机的 media query 语句生效了，就可以认为当前设备是移动设备。</p>
<p>window.matchMedia()方法接受一个 CSS 的 media query 语句作为参数，判断这个语句是否生效。</p>
<p>let isMobile = window.matchMedia(“only screen and (max-width: 760px)”).matches;<br>上面示例中，window.matchMedia()的参数是一个 CSS 查询语句，表示只对屏幕宽度不超过 700 像素的设备生效。它返回一个对象，该对象的matches属性是一个布尔值。如果是true，就表示查询生效，当前设备是手机。</p>
<p>除了通过屏幕宽度判断，还可以通过指针的精确性判断。</p>
<p>let isMobile = window.matchMedia(“(pointer:coarse)”).matches;<br>上面示例中，CSS 语句pointer:coarse表示当前设备的指针是不精确的。由于手机不支持鼠标，只支持触摸，所以符合这个条件。</p>
<p>有些设备支持多种指针，比如同时支持鼠标和触摸。pointer:coarse只用来判断主指针，此外还有一个any-pointer命令判断所有指针。</p>
<p>let isMobile = window.matchMedia(“(any-pointer:coarse)”).matches;<br>上面示例中，any-pointer:coarse表示所有指针里面，只要有一个指针是不精确的，就符合查询条件。</p>
<h2 id="六、工具包"><a href="#六、工具包" class="headerlink" title="六、工具包"></a>六、工具包</h2><p>除了上面这些方法，也可以使用别人写好的工具包。这里推荐 <code>react-device-detect</code>，它支持多种粒度的设备侦测。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;isMobile&#125; <span class="keyword">from</span> <span class="string">&#x27;react-device-detect&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isMobile) &#123;</span><br><span class="line">  <span class="comment">// 当前设备是移动设备</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（完）</p>
<link rel="stylesheet" href="/css/markmap.css" type="text/css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>新家落成，欢迎做客</title>
    <url>/blog/2015-06-19-%E6%96%B0%E5%AE%B6%E8%90%BD%E6%88%90%EF%BC%8C%E6%AC%A2%E8%BF%8E%E5%81%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>新家落成，欢迎常来做客！</p>
<link rel="stylesheet" href="/css/markmap.css" type="text/css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>随想录</category>
      </categories>
      <tags>
        <tag>随想录</tag>
        <tag>闪念记</tag>
        <tag>闲言语</tag>
      </tags>
  </entry>
  <entry>
    <title>App 启动流程</title>
    <url>/blog/2018-01-16-App%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p><a href="https://github.com/zhpanvip/AndroidNote/wiki/AMS%E6%A0%B8%E5%BF%83%E5%88%86%E6%9E%90">ActivityManagerService</a></p>
<h2 id="App启动流程分析"><a href="#App启动流程分析" class="headerlink" title="App启动流程分析"></a>App启动流程分析</h2><p>AndroidManifest文件中配置默认启动的Activity：    </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>系统在启动时会启动PMS服务，解析所有APP的AndroidManifest文件，在Launcher启动的时候就会将APP的图标及启动信息封装，在点击桌面上的APP图标时则出发APP的启动流程。APP的启动流程时序图如下：<span id="more"></span></p>
<p><img src="https://gitee.com/zhpanvip/images/raw/master/project/article/framework/app_start1.webp"></p>
<h2 id="Launcher"><a href="#Launcher" class="headerlink" title="Launcher"></a>Launcher</h2><p>Launcher是Android的桌面应用，在framework下有一个Launcher类，它集成子StateFulActivity，从本质上讲Launcher其实本身是一个Activity。点击APP的图标后，则会执行Launcher的startActivitySafely方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// packages/apps/Launcher3/src/com/android/launcher3/Launcher.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Launcher</span> <span class="keyword">extends</span> <span class="title class_">StatefulActivity</span>&lt;LauncherState&gt; <span class="keyword">implements</span> <span class="title class_">LauncherExterns</span>,</span><br><span class="line">        Callbacks, InvariantDeviceProfile.OnIDPChangeListener, PluginListener&lt;OverlayPlugin&gt; &#123;</span><br><span class="line">          </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">          </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startActivitySafely</span><span class="params">(View v, Intent intent, ItemInfo item,</span></span><br><span class="line"><span class="params">            <span class="meta">@Nullable</span> String sourceContainer)</span> &#123;</span><br><span class="line">				<span class="comment">// 调用父类的startActivitySafely</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> <span class="built_in">super</span>.startActivitySafely(v, intent, item, sourceContainer);</span><br><span class="line">        <span class="keyword">if</span> (success &amp;&amp; v <span class="keyword">instanceof</span> BubbleTextView) &#123;</span><br><span class="line">            <span class="type">BubbleTextView</span> <span class="variable">btv</span> <span class="operator">=</span> (BubbleTextView) v;</span><br><span class="line">            btv.setStayPressed(<span class="literal">true</span>);</span><br><span class="line">            addOnResumeCallback(btv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> success;</span><br><span class="line">    &#125;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Launcher的startActivitySafely直接调用到了其父类的startActivitySafely：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// packages/apps/Launcher3/src/com/android/launcher3/BaseDraggingActivity.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startActivitySafely</span><span class="params">(View v, Intent intent, <span class="meta">@Nullable</span> ItemInfo item,</span></span><br><span class="line"><span class="params">        <span class="meta">@Nullable</span> String sourceContainer)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mIsSafeModeEnabled &amp;&amp; !PackageManagerHelper.isSystemApp(<span class="built_in">this</span>, intent)) &#123;</span><br><span class="line">        Toast.makeText(<span class="built_in">this</span>, R.string.safemode_shortcut_error, Toast.LENGTH_SHORT).show();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Bundle</span> <span class="variable">optsBundle</span> <span class="operator">=</span> (v != <span class="literal">null</span>) ? getActivityLaunchOptionsAsBundle(v) : <span class="literal">null</span>;</span><br><span class="line">    <span class="type">UserHandle</span> <span class="variable">user</span> <span class="operator">=</span> item == <span class="literal">null</span> ? <span class="literal">null</span> : item.user;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里给Intent设置了FLAG_ACTIVITY_NEW_TASK，意味着新启动的Activity位于一个新任务栈</span></span><br><span class="line">    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">    <span class="keyword">if</span> (v != <span class="literal">null</span>) &#123;</span><br><span class="line">        intent.setSourceBounds(getViewBounds(v));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">if</span> (isShortcut) &#123;</span><br><span class="line">            <span class="comment">// 支持3D Touch功能</span></span><br><span class="line">            startShortcutIntentSafely(intent, optsBundle, item, sourceContainer);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (user == <span class="literal">null</span> || user.equals(Process.myUserHandle())) &#123;</span><br><span class="line">            <span class="comment">// 启动Activity</span></span><br><span class="line">            startActivity(intent, optsBundle);</span><br><span class="line">            AppLaunchTracker.INSTANCE.get(<span class="built_in">this</span>).onStartApp(intent.getComponent(),</span><br><span class="line">                    Process.myUserHandle(), sourceContainer);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            getSystemService(LauncherApps.class).startMainActivity(</span><br><span class="line">                    intent.getComponent(), user, intent.getSourceBounds(), optsBundle);</span><br><span class="line">            AppLaunchTracker.INSTANCE.get(<span class="built_in">this</span>).onStartApp(intent.getComponent(), user,</span><br><span class="line">                    sourceContainer);</span><br><span class="line">        &#125;</span><br><span class="line">        getUserEventDispatcher().logAppLaunch(v, intent, user);</span><br><span class="line">        <span class="keyword">if</span> (item != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">InstanceId</span> <span class="variable">instanceId</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InstanceIdSequence</span>().newInstanceId();</span><br><span class="line">            logAppLaunch(item, instanceId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException|ActivityNotFoundException|SecurityException e) &#123;</span><br><span class="line">        Toast.makeText(<span class="built_in">this</span>, R.string.activity_not_found, Toast.LENGTH_SHORT).show();</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;Unable to launch. tag=&quot;</span> + item + <span class="string">&quot; intent=&quot;</span> + intent, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以看到BaseDraggingActivity的startActivitySafely中调用了startActivity方法，而这个方法位于Activity中，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startActivity</span><span class="params">(Intent intent, <span class="meta">@Nullable</span> Bundle options)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (options != <span class="literal">null</span>) &#123;</span><br><span class="line">        startActivityForResult(intent, -<span class="number">1</span>, options);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Note we want to go through this call for compatibility with</span></span><br><span class="line">        <span class="comment">// applications that may have overridden the method.</span></span><br><span class="line">        startActivityForResult(intent, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着调用了startActivityForResult：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startActivityForResult</span><span class="params">(<span class="meta">@RequiresPermission</span> Intent intent, <span class="type">int</span> requestCode,</span></span><br><span class="line"><span class="params">        <span class="meta">@Nullable</span> Bundle options)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mParent == <span class="literal">null</span>) &#123;</span><br><span class="line">        options = transferSpringboardActivityOptions(options);</span><br><span class="line">        Instrumentation.<span class="type">ActivityResult</span> <span class="variable">ar</span> <span class="operator">=</span></span><br><span class="line">            mInstrumentation.execStartActivity(</span><br><span class="line">                <span class="built_in">this</span>, mMainThread.getApplicationThread(), mToken, <span class="built_in">this</span>,</span><br><span class="line">                intent, requestCode, options);</span><br><span class="line">			  <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mInstrumentation是Activity中的成员变量，用于监视应用程序和系统交互。mMainThread是ActivityThread类型的成员变量。通过 mMainThread.getApplicationThread() 获得 ApplicationThread，它是 ActivityThread 的一个内部类，是一个 Binder 对象。AMS 会通过 Application 来和 ActivityThread 进行进程间通信。</p>
<p>Instrumentation 的 execStartActivity 方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ActivityResult <span class="title function_">execStartActivity</span><span class="params">(</span></span><br><span class="line"><span class="params">        Context who, IBinder contextThread, IBinder token, Activity target,</span></span><br><span class="line"><span class="params">        Intent intent, <span class="type">int</span> requestCode, Bundle options)</span> &#123;</span><br><span class="line">  	<span class="comment">// 使用AIDL进行进程间通信，实现类为ActivityThread内部的ApplicationThread</span></span><br><span class="line">    <span class="type">IApplicationThread</span> <span class="variable">whoThread</span> <span class="operator">=</span> (IApplicationThread) contextThread;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        intent.migrateExtraStreamToClipData(who);</span><br><span class="line">        intent.prepareToLeaveProcess(who);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> ActivityTaskManager.getService().startActivity(whoThread,</span><br><span class="line">                who.getBasePackageName(), who.getAttributionTag(), intent,</span><br><span class="line">                intent.resolveTypeIfNeeded(who.getContentResolver()), token,</span><br><span class="line">                target != <span class="literal">null</span> ? target.mEmbeddedID : <span class="literal">null</span>, requestCode, <span class="number">0</span>, <span class="literal">null</span>, options);</span><br><span class="line">        checkStartActivityResult(result, intent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Failure from system&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/app/ActivityTaskManager.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> IActivityTaskManager <span class="title function_">getService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> IActivityTaskManagerSingleton.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@UnsupportedAppUsage(trackingBug = 129726065)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton&lt;IActivityTaskManager&gt; IActivityTaskManagerSingleton =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Singleton</span>&lt;IActivityTaskManager&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> IActivityTaskManager <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// 通过ServiceManager获取远程服务ActivityTaskManagerService</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">IBinder</span> <span class="variable">b</span> <span class="operator">=</span> ServiceManager.getService(Context.ACTIVITY_TASK_SERVICE);</span><br><span class="line">                <span class="comment">// 简历Launcher与ATMS的链接</span></span><br><span class="line">                <span class="keyword">return</span> IActivityTaskManager.Stub.asInterface(b);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>ServiceManager获取ActivityTaskManagerService，底层调用的是c++层的ServiceManager,它是Binder的守护服务，通过它能够在Android系统启动时注册系统服务，其中就包含提到的ATMS。接着通过IActivityTaskManager简历与ATMS的联系，这样回到execStartActivity方法，Launcher就通过调用ATMS的startActivity方法将启动Activity的数据交给了我ATMS服务来处理。</p>
<p>Launcher到ActivityTaskManagerService的时序图如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/1/17133beb378c39b0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p>
<h2 id="ActivityTaskManagerService-调用ApplicationThread"><a href="#ActivityTaskManagerService-调用ApplicationThread" class="headerlink" title="ActivityTaskManagerService 调用ApplicationThread"></a>ActivityTaskManagerService 调用ApplicationThread</h2><p>在Android10之中ActivityManagerService用于管理Activity及其容器的系统服务分离出来放到了ATMS中，ActivityTaskManagerService代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/wm/ActivityTaskManagerService.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">startActivity</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span><br><span class="line"><span class="params">        String callingFeatureId, Intent intent, String resolvedType, IBinder resultTo,</span></span><br><span class="line"><span class="params">        String resultWho, <span class="type">int</span> requestCode, <span class="type">int</span> startFlags, ProfilerInfo profilerInfo,</span></span><br><span class="line"><span class="params">        Bundle bOptions)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> startActivityAsUser(caller, callingPackage, callingFeatureId, intent, resolvedType,</span><br><span class="line">            resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions,</span><br><span class="line">            UserHandle.getCallingUserId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">startActivityAsUser</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span><br><span class="line"><span class="params">        String callingFeatureId, Intent intent, String resolvedType, IBinder resultTo,</span></span><br><span class="line"><span class="params">        String resultWho, <span class="type">int</span> requestCode, <span class="type">int</span> startFlags, ProfilerInfo profilerInfo,</span></span><br><span class="line"><span class="params">        Bundle bOptions, <span class="type">int</span> userId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> startActivityAsUser(caller, callingPackage, callingFeatureId, intent, resolvedType,</span><br><span class="line">            resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, userId,</span><br><span class="line">            <span class="literal">true</span> <span class="comment">/*validateIncomingUser*/</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">startActivityAsUser</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span><br><span class="line"><span class="params">        <span class="meta">@Nullable</span> String callingFeatureId, Intent intent, String resolvedType,</span></span><br><span class="line"><span class="params">        IBinder resultTo, String resultWho, <span class="type">int</span> requestCode, <span class="type">int</span> startFlags,</span></span><br><span class="line"><span class="params">        ProfilerInfo profilerInfo, Bundle bOptions, <span class="type">int</span> userId, <span class="type">boolean</span> validateIncomingUser)</span> &#123;</span><br><span class="line">    assertPackageMatchesCallingUid(callingPackage);</span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">&quot;startActivityAsUser&quot;</span>);</span><br><span class="line"></span><br><span class="line">    userId = getActivityStartController().checkTargetUser(userId, validateIncomingUser,</span><br><span class="line">            Binder.getCallingPid(), Binder.getCallingUid(), <span class="string">&quot;startActivityAsUser&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Switch to user app stacks here.</span></span><br><span class="line">  	<span class="comment">// 构造ActivityStarter</span></span><br><span class="line">    <span class="keyword">return</span> getActivityStartController().obtainStarter(intent, <span class="string">&quot;startActivityAsUser&quot;</span>)</span><br><span class="line">            .setCaller(caller)</span><br><span class="line">            .setCallingPackage(callingPackage)</span><br><span class="line">            .setCallingFeatureId(callingFeatureId)</span><br><span class="line">            .setResolvedType(resolvedType)</span><br><span class="line">            .setResultTo(resultTo)</span><br><span class="line">            .setResultWho(resultWho)</span><br><span class="line">            .setRequestCode(requestCode)</span><br><span class="line">            .setStartFlags(startFlags)</span><br><span class="line">            .setProfilerInfo(profilerInfo)</span><br><span class="line">            .setActivityOptions(bOptions)</span><br><span class="line">            .setUserId(userId)</span><br><span class="line">            .execute();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以发现，ActivityManagerService中startActivity() 方法调用了ActivityTaskManagerService的 startActivityAsUser() 方法，最后调用了 ActivityStartController.obtainStarter() 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ActivityStartController</span></span><br><span class="line">ActivityStarter <span class="title function_">obtainStarter</span><span class="params">(Intent intent, String reason)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mFactory.obtain().setIntent(intent).setReason(reason);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据注释得知 ActivityController 是以委托的方式把启动请求交给了一个包含所有启动信息的 ActivityStarter 对象并调用 execute 方法执行，ActivityStarter 的 execute() 方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/wm/ActivityStarter.java</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// TODO(b/64750076): Look into passing request directly to these methods to allow</span></span><br><span class="line">            <span class="comment">// for transactional diffs and preprocessing.</span></span><br><span class="line">            <span class="keyword">if</span> (mRequest.mayWait) &#123; <span class="comment">// 注释1</span></span><br><span class="line">                <span class="keyword">return</span> startActivityMayWait(mRequest.caller, mRequest.callingUid,</span><br><span class="line">                        mRequest.callingPackage, mRequest.realCallingPid, mRequest.realCallingUid,</span><br><span class="line">                        mRequest.intent, mRequest.resolvedType,</span><br><span class="line">                        mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo,</span><br><span class="line">                        mRequest.resultWho, mRequest.requestCode, mRequest.startFlags,</span><br><span class="line">                        mRequest.profilerInfo, mRequest.waitResult, mRequest.globalConfig,</span><br><span class="line">                        mRequest.activityOptions, mRequest.ignoreTargetSecurity, mRequest.userId,</span><br><span class="line">                        mRequest.inTask, mRequest.reason,</span><br><span class="line">                        mRequest.allowPendingRemoteAnimationRegistryLookup,</span><br><span class="line">                        mRequest.originatingPendingIntent, mRequest.allowBackgroundActivityStart);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> startActivity(mRequest.caller, mRequest.intent, mRequest.ephemeralIntent,</span><br><span class="line">                        mRequest.resolvedType, mRequest.activityInfo, mRequest.resolveInfo,</span><br><span class="line">                        mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo,</span><br><span class="line">                        mRequest.resultWho, mRequest.requestCode, mRequest.callingPid,</span><br><span class="line">                        mRequest.callingUid, mRequest.callingPackage, mRequest.realCallingPid,</span><br><span class="line">                        mRequest.realCallingUid, mRequest.startFlags, mRequest.activityOptions,</span><br><span class="line">                        mRequest.ignoreTargetSecurity, mRequest.componentSpecified,</span><br><span class="line">                        mRequest.outActivity, mRequest.inTask, mRequest.reason,</span><br><span class="line">                        mRequest.allowPendingRemoteAnimationRegistryLookup,</span><br><span class="line">                        mRequest.originatingPendingIntent, mRequest.allowBackgroundActivityStart);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            onExecutionComplete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由以上代码看到注释1，前面构造ActivityStarter已经传入了用户id，所以这里判断条件成立，则继续调用startActivityMayWait方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/wm/ActivityStarter.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">startActivityMayWait</span><span class="params">(IApplicationThread caller, <span class="type">int</span> callingUid,</span></span><br><span class="line"><span class="params">            String callingPackage, <span class="type">int</span> requestRealCallingPid, <span class="type">int</span> requestRealCallingUid,</span></span><br><span class="line"><span class="params">            Intent intent, String resolvedType, IVoiceInteractionSession voiceSession,</span></span><br><span class="line"><span class="params">            IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, <span class="type">int</span> requestCode,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> startFlags, ProfilerInfo profilerInfo, WaitResult outResult,</span></span><br><span class="line"><span class="params">            Configuration globalConfig, SafeActivityOptions options, <span class="type">boolean</span> ignoreTargetSecurity,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> userId, TaskRecord inTask, String reason,</span></span><br><span class="line"><span class="params">            <span class="type">boolean</span> allowPendingRemoteAnimationRegistryLookup,</span></span><br><span class="line"><span class="params">            PendingIntentRecord originatingPendingIntent, <span class="type">boolean</span> allowBackgroundActivityStart)</span> &#123;</span><br><span class="line">            ......  </span><br><span class="line">  <span class="keyword">final</span> ActivityRecord[] outRecord = <span class="keyword">new</span> <span class="title class_">ActivityRecord</span>[<span class="number">1</span>];<span class="comment">//1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> startActivity(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo,</span><br><span class="line">                voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid,</span><br><span class="line">                callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options,</span><br><span class="line">                ignoreTargetSecurity, componentSpecified, outRecord, inTask, reason,</span><br><span class="line">                allowPendingRemoteAnimationRegistryLookup, originatingPendingIntent,</span><br><span class="line">                allowBackgroundActivityStart);<span class="comment">//2</span></span><br><span class="line">      ......</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由以上代码，可以看到注释1处创建了一个ActivityRecord数组，ActivityRecord代表一个Activity,接着调用了startActivity方法，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/wm/ActivityStarter.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">startActivity</span><span class="params">(IApplicationThread caller, Intent intent, Intent ephemeralIntent,</span></span><br><span class="line"><span class="params">            String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,</span></span><br><span class="line"><span class="params">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span><br><span class="line"><span class="params">            IBinder resultTo, String resultWho, <span class="type">int</span> requestCode, <span class="type">int</span> callingPid, <span class="type">int</span> callingUid,</span></span><br><span class="line"><span class="params">            String callingPackage, <span class="type">int</span> realCallingPid, <span class="type">int</span> realCallingUid, <span class="type">int</span> startFlags,</span></span><br><span class="line"><span class="params">            SafeActivityOptions options,</span></span><br><span class="line"><span class="params">            <span class="type">boolean</span> ignoreTargetSecurity, <span class="type">boolean</span> componentSpecified, ActivityRecord[] outActivity,</span></span><br><span class="line"><span class="params">            TaskRecord inTask, <span class="type">boolean</span> allowPendingRemoteAnimationRegistryLookup,</span></span><br><span class="line"><span class="params">            PendingIntentRecord originatingPendingIntent, <span class="type">boolean</span> allowBackgroundActivityStart)</span> &#123;</span><br><span class="line">        mSupervisor.getActivityMetricsLogger().notifyActivityLaunching(intent);</span><br><span class="line">        <span class="type">int</span> <span class="variable">err</span> <span class="operator">=</span> ActivityManager.START_SUCCESS;</span><br><span class="line">        <span class="comment">// Pull the optional Ephemeral Installer-only bundle out of the options early.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Bundle</span> <span class="variable">verificationBundle</span></span><br><span class="line">                <span class="operator">=</span> options != <span class="literal">null</span> ? options.popAppVerificationBundle() : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">WindowProcessController</span> <span class="variable">callerApp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (caller != <span class="literal">null</span>) &#123;<span class="comment">//1</span></span><br><span class="line">        callerApp = mService.getProcessController(caller);<span class="comment">//2</span></span><br><span class="line">        <span class="keyword">if</span> (callerApp != <span class="literal">null</span>) &#123;</span><br><span class="line">            callingPid = callerApp.getPid();</span><br><span class="line">            callingUid = callerApp.mInfo.uid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">&quot;Unable to find app for caller &quot;</span> + caller</span><br><span class="line">                    + <span class="string">&quot; (pid=&quot;</span> + callingPid + <span class="string">&quot;) when starting: &quot;</span></span><br><span class="line">                    + intent.toString());</span><br><span class="line">            err = ActivityManager.START_PERMISSION_DENIED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   .......</span><br><span class="line"></span><br><span class="line">    <span class="type">ActivityRecord</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActivityRecord</span>(mService, callerApp, callingPid, callingUid,</span><br><span class="line">            callingPackage, intent, resolvedType, aInfo, mService.getGlobalConfiguration(),</span><br><span class="line">            resultRecord, resultWho, requestCode, componentSpecified, voiceSession != <span class="literal">null</span>,</span><br><span class="line">            mSupervisor, checkedOptions, sourceRecord);</span><br><span class="line">    <span class="keyword">if</span> (outActivity != <span class="literal">null</span>) &#123;</span><br><span class="line">        outActivity[<span class="number">0</span>] = r;<span class="comment">//3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> startActivity(r, sourceRecord, voiceSession, voiceInteractor, startFlags,</span><br><span class="line">            <span class="literal">true</span> <span class="comment">/* doResume */</span>, checkedOptions, inTask, outActivity, restrictedBgActivity);<span class="comment">//4</span></span><br><span class="line">    .....</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>startActivity里面有很多的逻辑代码，这里只看一些重点的逻辑代码：</p>
<ul>
<li><p>注释1处判断IApplicationThread是否为空，前面第一小节我们就已经提到过，它代表的就是Launcher进程的ApplicationThread，</p>
</li>
<li><p>注释2通过与即将要启动的应用程序进程建立联系，应用程序进程的是fork到Zyote进程，这里先不进行展开了,先专注Activity启动流程。</p>
</li>
<li><p>注释3创建ActivityRecord代表即将要启动的Activity，包含了Activity的所有信息，并赋值给上一步骤中创建的ActivityRecord类型的outActivity，</p>
</li>
<li><p>注释4则继续调用startActivity方法</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/wm/ActivityStarter.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">startActivity</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span><br><span class="line"><span class="params">                IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span><br><span class="line"><span class="params">                <span class="type">int</span> startFlags, <span class="type">boolean</span> doResume, ActivityOptions options, TaskRecord inTask,</span></span><br><span class="line"><span class="params">                ActivityRecord[] outActivity, <span class="type">boolean</span> restrictedBgActivity)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> START_CANCELED;</span><br><span class="line">        <span class="keyword">final</span> ActivityStack startedActivityStack;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mService.mWindowManager.deferSurfaceLayout();</span><br><span class="line">            result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor,</span><br><span class="line">                    startFlags, doResume, options, inTask, outActivity, restrictedBgActivity);<span class="comment">//1</span></span><br><span class="line">        &#125; </span><br><span class="line">        ........</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">startActivityUnchecked</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span><br><span class="line"><span class="params">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> startFlags, <span class="type">boolean</span> doResume, ActivityOptions options, TaskRecord inTask,</span></span><br><span class="line"><span class="params">            ActivityRecord[] outActivity, <span class="type">boolean</span> restrictedBgActivity)</span> &#123;</span><br><span class="line">        ......    </span><br><span class="line">        <span class="keyword">final</span> <span class="type">TaskRecord</span> <span class="variable">taskToAffiliate</span> <span class="operator">=</span> (mLaunchTaskBehind &amp;&amp; mSourceRecord != <span class="literal">null</span>)</span><br><span class="line">                ? mSourceRecord.getTaskRecord() : <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// Should this be considered a new task?</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> START_SUCCESS;</span><br><span class="line">        <span class="keyword">if</span> (mStartActivity.resultTo == <span class="literal">null</span> &amp;&amp; mInTask == <span class="literal">null</span> &amp;&amp; !mAddingToTask</span><br><span class="line">                &amp;&amp; (mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != <span class="number">0</span>) &#123; <span class="comment">//1</span></span><br><span class="line">            newTask = <span class="literal">true</span>;</span><br><span class="line">            result = setTaskFromReuseOrCreateNewTask(taskToAffiliate); <span class="comment">//2</span></span><br><span class="line">        &#125; </span><br><span class="line">        ........</span><br><span class="line">        <span class="keyword">if</span> (mDoResume) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ActivityRecord</span> <span class="variable">topTaskActivity</span> <span class="operator">=</span></span><br><span class="line">                    mStartActivity.getTaskRecord().topRunningActivityLocked();</span><br><span class="line">            <span class="keyword">if</span> (!mTargetStack.isFocusable()</span><br><span class="line">                    || (topTaskActivity != <span class="literal">null</span> &amp;&amp; topTaskActivity.mTaskOverlay</span><br><span class="line">                    &amp;&amp; mStartActivity != topTaskActivity)) &#123;</span><br><span class="line">                </span><br><span class="line">              mTargetStack.ensureActivitiesVisibleLocked(mStartActivity, <span class="number">0</span>, !PRESERVE_WINDOWS);</span><br><span class="line">                mTargetStack.getDisplay().mDisplayContent.executeAppTransition();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// If the target stack was not previously focusable (previous top running activity</span></span><br><span class="line">                <span class="comment">// on that stack was not visible) then any prior calls to move the stack to the</span></span><br><span class="line">                <span class="comment">// will not update the focused stack.  If starting the new activity now allows the</span></span><br><span class="line">                <span class="comment">// task stack to be focusable, then ensure that we now update the focused stack</span></span><br><span class="line">                <span class="comment">// accordingly.</span></span><br><span class="line">                <span class="keyword">if</span> (mTargetStack.isFocusable()</span><br><span class="line">                        &amp;&amp; !mRootActivityContainer.isTopDisplayFocusedStack(mTargetStack)) &#123;</span><br><span class="line">                    mTargetStack.moveToFront(<span class="string">&quot;startActivityUnchecked&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                mRootActivityContainer.resumeFocusedStacksTopActivities(</span><br><span class="line">                        mTargetStack, mStartActivity, mOptions);<span class="comment">//3</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注释1，在前面第一节Launcher部分中有提到过设置了Flag为<strong>FLAG_ACTIVITY_NEW_TASK</strong>，所以注意判断条件成立，则调用setTaskFromReuseOrCreateNewTask，它内部会创建的TaskRecord（代表Activity的任务栈），并将传入的TaskRecord对象设置给代表启动的Activity的ActivityRecord，</p>
<p>注释3调用了RootActivityContainer的resumeFocusedStacksTopActivities方法，RootActivityContainer 将一些东西从ActivityStackSupervisor中分离出来。目的是将其与RootWindowContainer合并，作为统一层次结构的一部分，接着看它的resumeFocusedStacksTopActivities方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/wm/RootActivityContainer.java</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">resumeFocusedStacksTopActivities</span><span class="params">(</span></span><br><span class="line"><span class="params">            ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions)</span> &#123;</span><br><span class="line">     <span class="comment">// ...</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (targetStack != <span class="literal">null</span> &amp;&amp; (targetStack.isTopStackOnDisplay()</span><br><span class="line">            || getTopDisplayFocusedStack() == targetStack)) &#123; </span><br><span class="line">      	<span class="comment">// 调用ActivityStack的resumeTopActivityUncheckedLocked</span></span><br><span class="line">        result = targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);<span class="comment">//1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/wm/ActivityStack.java</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">resumeTopActivityUncheckedLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mInResumeTopActivity) &#123;</span><br><span class="line">        <span class="comment">// Don&#x27;t even start recursing.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 防止递归</span></span><br><span class="line">        mInResumeTopActivity = <span class="literal">true</span>;</span><br><span class="line">        result = resumeTopActivityInnerLocked(prev, options); <span class="comment">//1</span></span><br><span class="line">        ........</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mInResumeTopActivity = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//确保栈顶 activity 为Resume</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">resumeTopActivityUncheckedLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mInResumeTopActivity) &#123;</span><br><span class="line">            <span class="comment">// Don&#x27;t even start recursing.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 防止递归</span></span><br><span class="line">            mInResumeTopActivity = <span class="literal">true</span>;</span><br><span class="line">            result = resumeTopActivityInnerLocked(prev, options); <span class="comment">//1</span></span><br><span class="line">            ........</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mInResumeTopActivity = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">resumeTopActivityInnerLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options)</span> &#123;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// ....</span></span><br><span class="line">   <span class="comment">// 调用ActivityStackSupervisor的startSpecificActivityLocked启动Activity</span></span><br><span class="line">   mStackSupervisor.startSpecificActivityLocked(next, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="ActivityStackSupervisor-启动Activity"><a href="#ActivityStackSupervisor-启动Activity" class="headerlink" title="ActivityStackSupervisor 启动Activity"></a>ActivityStackSupervisor 启动Activity</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/wm/ActivityStackSupervisor.java</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">startSpecificActivityLocked</span><span class="params">(ActivityRecord r, <span class="type">boolean</span> andResume, <span class="type">boolean</span> checkConfig)</span> &#123;</span><br><span class="line">    <span class="comment">// Is this activity&#x27;s application already running?</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">WindowProcessController</span> <span class="variable">wpc</span> <span class="operator">=</span></span><br><span class="line">            mService.getProcessController(r.processName, r.info.applicationInfo.uid);</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">knownToBeDead</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (wpc != <span class="literal">null</span> &amp;&amp; wpc.hasThread()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            realStartActivityLocked(r, wpc, andResume, checkConfig);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">&quot;Exception when starting activity &quot;</span></span><br><span class="line">                    + r.intent.getComponent().flattenToShortString(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If a dead object exception was thrown -- fall through to</span></span><br><span class="line">        <span class="comment">// restart the application.</span></span><br><span class="line">        knownToBeDead = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Suppress transition until the new activity becomes ready, otherwise the keyguard can</span></span><br><span class="line">    <span class="comment">// appear for a short amount of time before the new process with the new activity had the</span></span><br><span class="line">    <span class="comment">// ability to set its showWhenLocked flags.</span></span><br><span class="line">    <span class="keyword">if</span> (getKeyguardController().isKeyguardLocked()) &#123;</span><br><span class="line">        r.notifyUnknownVisibilityLaunched();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Trace.isTagEnabled(TRACE_TAG_ACTIVITY_MANAGER)) &#123;</span><br><span class="line">            Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;dispatchingStartProcess:&quot;</span></span><br><span class="line">                    + r.processName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Post message to start process to avoid possible deadlock of calling into AMS with the</span></span><br><span class="line">        <span class="comment">// ATMS lock held.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> PooledLambda.obtainMessage(</span><br><span class="line">                ActivityManagerInternal::startProcess, mService.mAmInternal, r.processName,</span><br><span class="line">                r.info.applicationInfo, knownToBeDead, <span class="string">&quot;activity&quot;</span>, r.intent.getComponent());</span><br><span class="line">        mService.mH.sendMessage(msg);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">realStartActivityLocked</span><span class="params">(ActivityRecord r, WindowProcessController proc,</span></span><br><span class="line"><span class="params">            <span class="type">boolean</span> andResume, <span class="type">boolean</span> checkConfig)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 创建ClientTransaction，包含一系列消息容器，发送到客户端，客户端即为要启动的应用的Activity</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">ClientTransaction</span> <span class="variable">clientTransaction</span> <span class="operator">=</span> ClientTransaction.obtain(</span><br><span class="line">                        proc.getThread(), r.appToken);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="type">DisplayContent</span> <span class="variable">dc</span> <span class="operator">=</span> r.getDisplay().mDisplayContent;</span><br><span class="line">    						<span class="comment">// 将启动Activity的参数封装成LaunchActivityItem请求request对象。</span></span><br><span class="line">                clientTransaction.addCallback(LaunchActivityItem.obtain(<span class="keyword">new</span> <span class="title class_">Intent</span>(r.intent),</span><br><span class="line">                        System.identityHashCode(r), r.info,</span><br><span class="line">                        <span class="comment">// <span class="doctag">TODO:</span> Have this take the merged configuration instead of separate global</span></span><br><span class="line">                        <span class="comment">// and override configs.</span></span><br><span class="line">                        mergedConfiguration.getGlobalConfiguration(),</span><br><span class="line">                        mergedConfiguration.getOverrideConfiguration(), r.compat,</span><br><span class="line">                        r.launchedFromPackage, task.voiceInteractor, proc.getReportedProcState(),</span><br><span class="line">                        r.icicle, r.persistentState, results, newIntents,</span><br><span class="line">                        dc.isNextTransitionForward(), proc.createProfilerInfoIfNeeded(),</span><br><span class="line">                                r.assistToken));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Set desired final state.</span></span><br><span class="line">                <span class="keyword">final</span> ActivityLifecycleItem lifecycleItem;</span><br><span class="line">                <span class="keyword">if</span> (andResume) &#123;</span><br><span class="line">                    lifecycleItem = ResumeActivityItem.obtain(dc.isNextTransitionForward());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    lifecycleItem = PauseActivityItem.obtain();</span><br><span class="line">                &#125;</span><br><span class="line">                clientTransaction.setLifecycleStateRequest(lifecycleItem);</span><br><span class="line">                <span class="comment">// 调用ClientLifecycleManager的scheduleTransaction方法</span></span><br><span class="line">                mService.getLifecycleManager().scheduleTransaction(clientTransaction);</span><br><span class="line">               <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="ClientLifecycleManager处理ClientTransaction"><a href="#ClientLifecycleManager处理ClientTransaction" class="headerlink" title="ClientLifecycleManager处理ClientTransaction"></a>ClientLifecycleManager处理ClientTransaction</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/wm/ClientLifecycleManager.java</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">scheduleTransaction</span><span class="params">(ClientTransaction transaction)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    <span class="comment">// 获取要启动的应用程序进程的IAppClicationThread</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">IApplicationThread</span> <span class="variable">client</span> <span class="operator">=</span> transaction.getClient();</span><br><span class="line">    <span class="comment">// 调用ClientTransaction的schedule方法</span></span><br><span class="line">    transaction.schedule();<span class="comment">//2</span></span><br><span class="line">    <span class="keyword">if</span> (!(client <span class="keyword">instanceof</span> Binder)) &#123;</span><br><span class="line">        <span class="comment">// If client is not an instance of Binder - it&#x27;s a remote call and at this point it is</span></span><br><span class="line">        <span class="comment">// safe to recycle the object. All objects used for local calls will be recycled after</span></span><br><span class="line">        <span class="comment">// the transaction is executed on client in ActivityThread.</span></span><br><span class="line">        transaction.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/app/servertransaction/ClientTransaction.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">schedule</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    mClient.scheduleTransaction(<span class="built_in">this</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mClient则代表要启动的应用程序进程的IApplicationThread，而当前还处于ATMS服务的进程，也就是SystemServer进程，这时ATMS要与即将启动的应用程序进程通信则通过IApplicationThread来执行AIDL，IApplicationThread实现为ApplicationThread，它是ActivityThread的内部类，所以前面也说过ApplicationThread为进程间通信的桥梁，接下来则相当于是IApplicationThread.scheduleTransaction，并将包含要启动Activity信息的ClientTransaction传递到了应用程序进程，下一节就从IApplicationThread讲起。</p>
<h3 id="AMTS调用到ApplicationThread时序图"><a href="#AMTS调用到ApplicationThread时序图" class="headerlink" title="AMTS调用到ApplicationThread时序图"></a>AMTS调用到ApplicationThread时序图</h3><p><img src="https://user-gold-cdn.xitu.io/2020/4/1/17133beb3e0359e2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p>
<h2 id="ActivityThread启动Activity"><a href="#ActivityThread启动Activity" class="headerlink" title="ActivityThread启动Activity"></a>ActivityThread启动Activity</h2><p>ApplicationThread的scheduleTransaction方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/app/ActivityThread$ApplicationThread</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ApplicationThread</span> <span class="keyword">extends</span> <span class="title class_">IApplicationThread</span>.Stub &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scheduleTransaction</span><span class="params">(ClientTransaction transaction)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">        ActivityThread.<span class="built_in">this</span>.scheduleTransaction(transaction);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码调用了ActivityThread的scheduleTransaction方法，ActivityThread继承了ClientTransactionHandler，scheduleTransaction在里面实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/app/ClientTransactionHandler.java</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">scheduleTransaction</span><span class="params">(ClientTransaction transaction)</span> &#123;</span><br><span class="line">    transaction.preExecute(<span class="built_in">this</span>);</span><br><span class="line">    sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">H</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="string">&quot;&gt;&gt;&gt; handling: &quot;</span> + codeToString(msg.what));</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;                    <span class="keyword">case</span> EXECUTE_TRANSACTION:</span><br><span class="line">                <span class="keyword">final</span> <span class="type">ClientTransaction</span> <span class="variable">transaction</span> <span class="operator">=</span> (ClientTransaction) msg.obj;</span><br><span class="line">                mTransactionExecutor.execute(transaction);</span><br><span class="line">                <span class="keyword">if</span> (isSystem()) &#123;</span><br><span class="line">                    transaction.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用TransactionExecutor的execute方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/app/servertransaction/TransactionExecutor.java</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(ClientTransaction transaction)</span> &#123;</span><br><span class="line">       executeCallbacks(transaction);</span><br><span class="line">			<span class="comment">// ...</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeCallbacks</span><span class="params">(ClientTransaction transaction)</span> &#123;</span><br><span class="line">       <span class="keyword">final</span> List&lt;ClientTransactionItem&gt; callbacks = transaction.getCallbacks();</span><br><span class="line">       <span class="keyword">if</span> (callbacks == <span class="literal">null</span> || callbacks.isEmpty()) &#123;</span><br><span class="line">           <span class="comment">// No callbacks to execute, return early.</span></span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (DEBUG_RESOLVER) Slog.d(TAG, tId(transaction) + <span class="string">&quot;Resolving callbacks in transaction&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> <span class="type">IBinder</span> <span class="variable">token</span> <span class="operator">=</span> transaction.getActivityToken();</span><br><span class="line">       <span class="type">ActivityClientRecord</span> <span class="variable">r</span> <span class="operator">=</span> mTransactionHandler.getActivityClient(token);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// In case when post-execution state of the last callback matches the final state requested</span></span><br><span class="line">       <span class="comment">// for the activity in this transaction, we won&#x27;t do the last transition here and do it when</span></span><br><span class="line">       <span class="comment">// moving to final state instead (because it may contain additional parameters from server).</span></span><br><span class="line">       <span class="keyword">final</span> <span class="type">ActivityLifecycleItem</span> <span class="variable">finalStateRequest</span> <span class="operator">=</span> transaction.getLifecycleStateRequest();</span><br><span class="line">       <span class="keyword">final</span> <span class="type">int</span> <span class="variable">finalState</span> <span class="operator">=</span> finalStateRequest != <span class="literal">null</span> ? finalStateRequest.getTargetState()</span><br><span class="line">               : UNDEFINED;</span><br><span class="line">       <span class="comment">// Index of the last callback that requests some post-execution state.</span></span><br><span class="line">       <span class="keyword">final</span> <span class="type">int</span> <span class="variable">lastCallbackRequestingState</span> <span class="operator">=</span> lastCallbackRequestingState(transaction);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> callbacks.size();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="type">ClientTransactionItem</span> <span class="variable">item</span> <span class="operator">=</span> callbacks.get(i);</span><br><span class="line">           <span class="keyword">if</span> (DEBUG_RESOLVER) Slog.d(TAG, tId(transaction) + <span class="string">&quot;Resolving callback: &quot;</span> + item);</span><br><span class="line">           <span class="keyword">final</span> <span class="type">int</span> <span class="variable">postExecutionState</span> <span class="operator">=</span> item.getPostExecutionState();</span><br><span class="line">           <span class="keyword">final</span> <span class="type">int</span> <span class="variable">closestPreExecutionState</span> <span class="operator">=</span> mHelper.getClosestPreExecutionState(r,</span><br><span class="line">                   item.getPostExecutionState());</span><br><span class="line">           <span class="keyword">if</span> (closestPreExecutionState != UNDEFINED) &#123;</span><br><span class="line">               cycleToPath(r, closestPreExecutionState, transaction);</span><br><span class="line">           &#125;</span><br><span class="line">					<span class="comment">// LaunchActivityItem的execute</span></span><br><span class="line">           item.execute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">           item.postExecute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">           <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="comment">// Launch activity request will create an activity record.</span></span><br><span class="line">               r = mTransactionHandler.getActivityClient(token);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (postExecutionState != UNDEFINED &amp;&amp; r != <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="comment">// Skip the very last transition and perform it by explicit state request instead.</span></span><br><span class="line">               <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">shouldExcludeLastTransition</span> <span class="operator">=</span></span><br><span class="line">                       i == lastCallbackRequestingState &amp;&amp; finalState == postExecutionState;</span><br><span class="line">               cycleToPath(r, postExecutionState, shouldExcludeLastTransition, transaction);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>获取的ClientTransactionItem则为第二小节中提到过的LaunchActivityItem对象，它继承了ClientTransactionItem，并保存这需要启动的Activity数据，接着看到注释2 LaunchActivityItem的execute方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(ClientTransactionHandler client, IBinder token,</span></span><br><span class="line"><span class="params">        PendingTransactionActions pendingActions)</span> &#123;</span><br><span class="line">    Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;activityStart&quot;</span>);</span><br><span class="line">    <span class="comment">// 恢复要启动的Activity的数据</span></span><br><span class="line">    <span class="type">ActivityClientRecord</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActivityClientRecord</span>(token, mIntent, mIdent, mInfo,</span><br><span class="line">            mOverrideConfig, mCompatInfo, mReferrer, mVoiceInteractor, mState, mPersistentState,</span><br><span class="line">            mPendingResults, mPendingNewIntents, mIsForward,</span><br><span class="line">            mProfilerInfo, client, mAssistToken);</span><br><span class="line">    <span class="comment">// ActivityThread的handleLaunchActivity</span></span><br><span class="line">    client.handleLaunchActivity(r, pendingActions, <span class="literal">null</span> <span class="comment">/* customIntent */</span>);</span><br><span class="line">    Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>恢复了要启动的Activity的数据，ActivityClientRecord是ActivityThread的内部类，这里的client为ClientTransactionHandler，而前面已经说过ActivityThread继承ClientTransactionHandler，所以这里的注释2处调用的就是ActivityThread的handleLaunchActivity方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/app/ActivityThread.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Activity <span class="title function_">handleLaunchActivity</span><span class="params">(ActivityClientRecord r,</span></span><br><span class="line"><span class="params">        PendingTransactionActions pendingActions, Intent customIntent)</span> &#123;</span><br><span class="line">  	<span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">final</span> <span class="type">Activity</span> <span class="variable">a</span> <span class="operator">=</span> performLaunchActivity(r, customIntent);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Activity <span class="title function_">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取了前面保存启动应用程序信息的ActivityClientRecord中的应用程序信息，包括应用程序在清单文件中注册了哪些四大组件，启动的根Activity是什么</span></span><br><span class="line">        <span class="type">ActivityInfo</span> <span class="variable">aInfo</span> <span class="operator">=</span> r.activityInfo;</span><br><span class="line">        <span class="keyword">if</span> (r.packageInfo == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 2.通过getPackageInfo方法获取LoadedApk描述对应Apk文件资源</span></span><br><span class="line">            r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,</span><br><span class="line">                    Context.CONTEXT_INCLUDE_CODE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.ComponentName类获取则对应启动Activity的包名和类名</span></span><br><span class="line">        <span class="type">ComponentName</span> <span class="variable">component</span> <span class="operator">=</span> r.intent.getComponent();</span><br><span class="line">        <span class="keyword">if</span> (component == <span class="literal">null</span>) &#123;</span><br><span class="line">            component = r.intent.resolveActivity(</span><br><span class="line">                mInitialApplication.getPackageManager());</span><br><span class="line">            r.intent.setComponent(component);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r.activityInfo.targetActivity != <span class="literal">null</span>) &#123;</span><br><span class="line">            component = <span class="keyword">new</span> <span class="title class_">ComponentName</span>(r.activityInfo.packageName,</span><br><span class="line">                    r.activityInfo.targetActivity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.应用程序Context的创建</span></span><br><span class="line">        <span class="type">ContextImpl</span> <span class="variable">appContext</span> <span class="operator">=</span> createBaseContextForActivity(r);</span><br><span class="line">        <span class="type">Activity</span> <span class="variable">activity</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        </span><br><span class="line">            java.lang.<span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> appContext.getClassLoader();</span><br><span class="line">            <span class="comment">// 5.通过类加载器和Intent对象实例化了Activity对象</span></span><br><span class="line">            activity = mInstrumentation.newActivity(</span><br><span class="line">                    cl, component.getClassName(), r.intent);</span><br><span class="line">            StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">            r.intent.setExtrasClassLoader(cl);</span><br><span class="line">            r.intent.prepareToEnterProcess();</span><br><span class="line">            <span class="keyword">if</span> (r.state != <span class="literal">null</span>) &#123;</span><br><span class="line">                r.state.setClassLoader(cl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mInstrumentation.onException(activity, e)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                    <span class="string">&quot;Unable to instantiate activity &quot;</span> + component</span><br><span class="line">                    + <span class="string">&quot;: &quot;</span> + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        </span><br><span class="line">           <span class="comment">// 6.根据上面获取到的Apk描述对象LoadedApk创建了应用程序的Application对象，</span></span><br><span class="line">           <span class="comment">// 并在makeApplication方法中调用了它的OnCreate方法,此时Application启动</span></span><br><span class="line">            <span class="type">Application</span> <span class="variable">app</span> <span class="operator">=</span> r.packageInfo.makeApplication(<span class="literal">false</span>, mInstrumentation);</span><br><span class="line"></span><br><span class="line">           ......</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (activity != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">CharSequence</span> <span class="variable">title</span> <span class="operator">=</span> r.activityInfo.loadLabel(appContext.getPackageManager());</span><br><span class="line">                <span class="type">Configuration</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>(mCompatConfiguration);</span><br><span class="line">                <span class="keyword">if</span> (r.overrideConfig != <span class="literal">null</span>) &#123;</span><br><span class="line">                    config.updateFrom(r.overrideConfig);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_CONFIGURATION) Slog.v(TAG, <span class="string">&quot;Launching activity &quot;</span></span><br><span class="line">                        + r.activityInfo.name + <span class="string">&quot; with config &quot;</span> + config);</span><br><span class="line">                <span class="type">Window</span> <span class="variable">window</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (r.mPendingRemoveWindow != <span class="literal">null</span> &amp;&amp; r.mPreserveWindow) &#123;</span><br><span class="line">                    window = r.mPendingRemoveWindow;</span><br><span class="line">                    r.mPendingRemoveWindow = <span class="literal">null</span>;</span><br><span class="line">                    r.mPendingRemoveWindowManager = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                appContext.setOuterContext(activity);</span><br><span class="line">                <span class="comment">// 7.通过Activity的 attach 方法将 context等各种数据与Activity绑定，初始化Activity</span></span><br><span class="line">                activity.attach(appContext, <span class="built_in">this</span>, getInstrumentation(), r.token,</span><br><span class="line">                        r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                        r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                        r.referrer, r.voiceInteractor, window, r.configCallback,</span><br><span class="line">                        r.assistToken); </span><br><span class="line"></span><br><span class="line">                ......</span><br><span class="line">                <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">                    <span class="comment">// 8.Instrumentation对象的callActivityOnCreate方法</span></span><br><span class="line">                    mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">                r.activity = activity;</span><br><span class="line">            &#125;</span><br><span class="line">            r.setState(ON_CREATE);</span><br><span class="line"></span><br><span class="line">           .......</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Activity的-OnCreate方法调用"><a href="#Activity的-OnCreate方法调用" class="headerlink" title="Activity的 OnCreate方法调用"></a>Activity的 OnCreate方法调用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/app/Instrumentation.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">callActivityOnCreate</span><span class="params">(Activity activity, Bundle icicle)</span> &#123;</span><br><span class="line">    prePerformCreate(activity);</span><br><span class="line">    <span class="comment">// 调用Activity的performCreate</span></span><br><span class="line">    activity.performCreate(icicle);</span><br><span class="line">    postPerformCreate(activity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/android/app/Activity.java</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">performCreate</span><span class="params">(Bundle icicle)</span> &#123;</span><br><span class="line">    performCreate(icicle, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">performCreate</span><span class="params">(Bundle icicle, PersistableBundle persistentState)</span> &#123;</span><br><span class="line">    dispatchActivityPreCreated(icicle);</span><br><span class="line">    mCanEnterPictureInPicture = <span class="literal">true</span>;</span><br><span class="line">    restoreHasCurrentPermissionRequest(icicle);</span><br><span class="line">    <span class="keyword">if</span> (persistentState != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Activity已经实例化</span></span><br><span class="line">        onCreate(icicle, persistentState);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 调用Activity的onCreate方法</span></span><br><span class="line">        onCreate(icicle);</span><br><span class="line">    &#125;</span><br><span class="line">    writeEventLog(LOG_AM_ON_CREATE_CALLED, <span class="string">&quot;performCreate&quot;</span>);</span><br><span class="line">    mActivityTransitionState.readState(icicle);</span><br><span class="line"></span><br><span class="line">    mVisibleFromClient = !mWindow.getWindowStyle().getBoolean(</span><br><span class="line">            com.android.internal.R.styleable.Window_windowNoDisplay, <span class="literal">false</span>);</span><br><span class="line">    mFragments.dispatchActivityCreated();</span><br><span class="line">    mActivityTransitionState.setEnterActivityOptions(<span class="built_in">this</span>, getActivityOptions());</span><br><span class="line">    dispatchActivityPostCreated(icicle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ActivityThread启动Activity的时序图"><a href="#ActivityThread启动Activity的时序图" class="headerlink" title="ActivityThread启动Activity的时序图"></a>ActivityThread启动Activity的时序图</h3><p><img src="https://user-gold-cdn.xitu.io/2020/4/1/17133beb3c7a9e75?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p>
<p>[深入理解Android 之 Activity启动流程（Android 10）](</p>
<link rel="stylesheet" href="/css/markmap.css" type="text/css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
</search>
